Index: qrcode/src/main/java/com/google/zxing/client/android/camera/CameraManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * Copyright (C) 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.zxing.client.android.camera;\n\nimport android.content.Context;\nimport android.graphics.Point;\nimport android.graphics.Rect;\nimport android.hardware.Camera;\nimport android.os.Handler;\nimport android.util.Log;\nimport android.view.SurfaceHolder;\n\nimport com.google.zxing.PlanarYUVLuminanceSource;\nimport com.google.zxing.client.android.camera.open.OpenCamera;\nimport com.google.zxing.client.android.camera.open.OpenCameraInterface;\n\nimport java.io.IOException;\n\n/**\n * This object wraps the Camera service object and expects to be the only one talking to it. The\n * implementation encapsulates the steps needed to take preview-sized images, which are used for\n * both preview and decoding.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\n@SuppressWarnings(\"deprecation\") // camera APIs\npublic final class CameraManager {\n\n    private static final String TAG = CameraManager.class.getSimpleName();\n\n    private static final int MIN_FRAME_WIDTH = 240;\n    private static final int MIN_FRAME_HEIGHT = 240;\n    private static final int MAX_FRAME_WIDTH = 1200; // = 5/8 * 1920\n    private static final int MAX_FRAME_HEIGHT = 675; // = 5/8 * 1080\n\n    private final Context context;\n    private final CameraConfigurationManager configManager;\n    private OpenCamera camera;\n    private AutoFocusManager autoFocusManager;\n    private Rect framingRect;\n    private Rect framingRectInPreview;\n    private boolean initialized;\n    private boolean previewing;\n    private int requestedCameraId = OpenCameraInterface.NO_REQUESTED_CAMERA;\n    private int requestedFramingRectWidth;\n    private int requestedFramingRectHeight;\n    /**\n     * Preview frames are delivered here, which we pass on to the registered handler. Make sure to\n     * clear the handler so it will only receive one message.\n     */\n    private final PreviewCallback previewCallback;\n\n    public CameraManager(Context context) {\n        this.context = context;\n        this.configManager = new CameraConfigurationManager(context);\n        previewCallback = new PreviewCallback(configManager);\n    }\n\n    /**\n     * Opens the camera driver and initializes the hardware parameters.\n     *\n     * @param holder The surface object which the camera will draw preview frames into.\n     * @throws IOException Indicates the camera driver failed to open.\n     */\n    public synchronized void openDriver(SurfaceHolder holder) throws IOException {\n        OpenCamera theCamera = camera;\n        if (theCamera == null) {\n            theCamera = OpenCameraInterface.open(requestedCameraId);\n            if (theCamera == null) {\n                throw new IOException(\"Camera.open() failed to return object from driver\");\n            }\n            camera = theCamera;\n        }\n\n        if (!initialized) {\n            initialized = true;\n            configManager.initFromCameraParameters(theCamera);\n            if (requestedFramingRectWidth > 0 && requestedFramingRectHeight > 0) {\n                setManualFramingRect(requestedFramingRectWidth, requestedFramingRectHeight);\n                requestedFramingRectWidth = 0;\n                requestedFramingRectHeight = 0;\n            }\n        }\n\n        Camera cameraObject = theCamera.getCamera();\n        Camera.Parameters parameters = cameraObject.getParameters();\n        String parametersFlattened = parameters == null ? null : parameters.flatten(); // Save these, temporarily\n        try {\n            configManager.setDesiredCameraParameters(theCamera, false);\n        } catch (RuntimeException re) {\n            // Driver failed\n            Log.w(TAG, \"Camera rejected parameters. Setting only minimal safe-mode parameters\");\n            Log.i(TAG, \"Resetting to saved camera params: \" + parametersFlattened);\n            // Reset:\n            if (parametersFlattened != null) {\n                parameters = cameraObject.getParameters();\n                parameters.unflatten(parametersFlattened);\n                try {\n                    cameraObject.setParameters(parameters);\n                    configManager.setDesiredCameraParameters(theCamera, true);\n                } catch (RuntimeException re2) {\n                    // Well, darn. Give up\n                    Log.w(TAG, \"Camera rejected even safe-mode parameters! No configuration\");\n                }\n            }\n        }\n        cameraObject.setPreviewDisplay(holder);\n\n    }\n\n    public synchronized boolean isOpen() {\n        return camera != null;\n    }\n\n    /**\n     * Closes the camera driver if still in use.\n     */\n    public synchronized void closeDriver() {\n        if (camera != null) {\n            camera.getCamera().release();\n            camera = null;\n            // Make sure to clear these each time we close the camera, so that any scanning rect\n            // requested by intent is forgotten.\n            framingRect = null;\n            framingRectInPreview = null;\n        }\n    }\n\n    /**\n     * Asks the camera hardware to begin drawing preview frames to the screen.\n     */\n    public synchronized void startPreview() {\n        OpenCamera theCamera = camera;\n        if (theCamera != null && !previewing) {\n            theCamera.getCamera().startPreview();\n            previewing = true;\n            autoFocusManager = new AutoFocusManager(context, theCamera.getCamera());\n        }\n    }\n\n    /**\n     * Tells the camera to stop drawing preview frames.\n     */\n    public synchronized void stopPreview() {\n        if (autoFocusManager != null) {\n            autoFocusManager.stop();\n            autoFocusManager = null;\n        }\n        if (camera != null && previewing) {\n            camera.getCamera().stopPreview();\n            previewCallback.setHandler(null, 0);\n            previewing = false;\n        }\n    }\n\n    /**\n     * Convenience method for {@link com.google.zxing.client.android.CaptureActivity}\n     *\n     * @param newSetting if {@code true}, light should be turned on if currently off. And vice versa.\n     */\n    public synchronized void setTorch(boolean newSetting) {\n        OpenCamera theCamera = camera;\n        if (theCamera != null && newSetting != configManager.getTorchState(theCamera.getCamera())) {\n            boolean wasAutoFocusManager = autoFocusManager != null;\n            if (wasAutoFocusManager) {\n                autoFocusManager.stop();\n                autoFocusManager = null;\n            }\n            configManager.setTorch(theCamera.getCamera(), newSetting);\n            if (wasAutoFocusManager) {\n                autoFocusManager = new AutoFocusManager(context, theCamera.getCamera());\n                autoFocusManager.start();\n            }\n        }\n    }\n\n    /**\n     * A single preview frame will be returned to the handler supplied. The data will arrive as byte[]\n     * in the message.obj field, with width and height encoded as message.arg1 and message.arg2,\n     * respectively.\n     *\n     * @param handler The handler to send the message to.\n     * @param message The what field of the message to be sent.\n     */\n    public synchronized void requestPreviewFrame(Handler handler, int message) {\n        OpenCamera theCamera = camera;\n        if (theCamera != null && previewing) {\n            previewCallback.setHandler(handler, message);\n            theCamera.getCamera().setOneShotPreviewCallback(previewCallback);\n        }\n    }\n\n    /**\n     * Calculates the framing rect which the UI should draw to show the user where to place the\n     * barcode. This target helps with alignment as well as forces the user to hold the device\n     * far enough away to ensure the image will be in focus.\n     *\n     * @return The rectangle to draw on screen in window coordinates.\n     */\n    public synchronized Rect getFramingRect() {\n        if (framingRect == null) {\n            if (camera == null) {\n                return null;\n            }\n            Point screenResolution = configManager.getScreenResolution();\n            if (screenResolution == null) {\n                // Called early, before init even finished\n                return null;\n            }\n\n            int width = findDesiredDimensionInRange(screenResolution.x, MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);\n            int height = findDesiredDimensionInRange(screenResolution.y, MIN_FRAME_HEIGHT, MAX_FRAME_HEIGHT);\n\n            int leftOffset = (screenResolution.x - width) / 2;\n            int topOffset = (screenResolution.y - height) / 2;\n            framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);\n            Log.d(TAG, \"Calculated framing rect: \" + framingRect);\n        }\n        return framingRect;\n    }\n\n    private static int findDesiredDimensionInRange(int resolution, int hardMin, int hardMax) {\n        int dim = 5 * resolution / 8; // Target 5/8 of each dimension\n        if (dim < hardMin) {\n            return hardMin;\n        }\n        if (dim > hardMax) {\n            return hardMax;\n        }\n        return dim;\n    }\n\n    /**\n     * Like {@link #getFramingRect} but coordinates are in terms of the preview frame,\n     * not UI / screen.\n     *\n     * @return {@link Rect} expressing barcode scan area in terms of the preview size\n     */\n    public synchronized Rect getFramingRectInPreview() {\n        if (framingRectInPreview == null) {\n            Rect framingRect = getFramingRect();\n            if (framingRect == null) {\n                return null;\n            }\n            Rect rect = new Rect(framingRect);\n            Point cameraResolution = configManager.getCameraResolution();\n            Point screenResolution = configManager.getScreenResolution();\n            if (cameraResolution == null || screenResolution == null) {\n                // Called early, before init even finished\n                return null;\n            }\n            rect.left = rect.left * cameraResolution.x / screenResolution.x;\n            rect.right = rect.right * cameraResolution.x / screenResolution.x;\n            rect.top = rect.top * cameraResolution.y / screenResolution.y;\n            rect.bottom = rect.bottom * cameraResolution.y / screenResolution.y;\n            framingRectInPreview = rect;\n        }\n        return framingRectInPreview;\n    }\n\n\n    /**\n     * Allows third party apps to specify the camera ID, rather than determine\n     * it automatically based on available cameras and their orientation.\n     *\n     * @param cameraId camera ID of the camera to use. A negative value means \"no preference\".\n     */\n    public synchronized void setManualCameraId(int cameraId) {\n        requestedCameraId = cameraId;\n    }\n\n    /**\n     * Allows third party apps to specify the scanning rectangle dimensions, rather than determine\n     * them automatically based on screen resolution.\n     *\n     * @param width  The width in pixels to scan.\n     * @param height The height in pixels to scan.\n     */\n    public synchronized void setManualFramingRect(int width, int height) {\n        if (initialized) {\n            Point screenResolution = configManager.getScreenResolution();\n            if (width > screenResolution.x) {\n                width = screenResolution.x;\n            }\n            if (height > screenResolution.y) {\n                height = screenResolution.y;\n            }\n            int leftOffset = (screenResolution.x - width) / 2;\n            int topOffset = (screenResolution.y - height) / 2;\n            framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);\n            Log.d(TAG, \"Calculated manual framing rect: \" + framingRect);\n            framingRectInPreview = null;\n        } else {\n            requestedFramingRectWidth = width;\n            requestedFramingRectHeight = height;\n        }\n    }\n\n    /**\n     * A factory method to build the appropriate LuminanceSource object based on the format\n     * of the preview buffers, as described by Camera.Parameters.\n     *\n     * @param data   A preview frame.\n     * @param width  The width of the image.\n     * @param height The height of the image.\n     * @return A PlanarYUVLuminanceSource instance.\n     */\n    public PlanarYUVLuminanceSource buildLuminanceSource(byte[] data, int width, int height) {\n        Rect rect = getFramingRectInPreview();\n        if (rect == null) {\n            return null;\n        }\n        // Go ahead and assume it's YUV rather than die.\n        return new PlanarYUVLuminanceSource(data, width, height, rect.left, rect.top,\n                rect.width(), rect.height(), false);\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- qrcode/src/main/java/com/google/zxing/client/android/camera/CameraManager.java	(date 1545458417000)
+++ qrcode/src/main/java/com/google/zxing/client/android/camera/CameraManager.java	
@@ -44,8 +44,8 @@
 
     private static final int MIN_FRAME_WIDTH = 240;
     private static final int MIN_FRAME_HEIGHT = 240;
-    private static final int MAX_FRAME_WIDTH = 1200; // = 5/8 * 1920
-    private static final int MAX_FRAME_HEIGHT = 675; // = 5/8 * 1080
+    private static final int MAX_FRAME_WIDTH = 1440; // = 3/4 * 1920
+    private static final int MAX_FRAME_HEIGHT = 810; // = 3/4 * 1080
 
     private final Context context;
     private final CameraConfigurationManager configManager;
@@ -224,6 +224,11 @@
 
             int width = findDesiredDimensionInRange(screenResolution.x, MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);
             int height = findDesiredDimensionInRange(screenResolution.y, MIN_FRAME_HEIGHT, MAX_FRAME_HEIGHT);
+            Log.d(TAG, "getFramingRect width: " + width + ",height: " + height);
+            //取景框设为正方形
+            int min = Math.min(width, height);
+            width = min;
+            height = min;
 
             int leftOffset = (screenResolution.x - width) / 2;
             int topOffset = (screenResolution.y - height) / 2;
@@ -234,7 +239,7 @@
     }
 
     private static int findDesiredDimensionInRange(int resolution, int hardMin, int hardMax) {
-        int dim = 5 * resolution / 8; // Target 5/8 of each dimension
+        int dim = 3 * resolution / 4; // Target 3/4 of each dimension
         if (dim < hardMin) {
             return hardMin;
         }
