Index: qrcode/src/main/java/com/google/zxing/client/android/PreferencesActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * Copyright (C) 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.zxing.client.android;\n\nimport android.app.Activity;\nimport android.os.Bundle;\n\n/**\n * The main settings activity.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n */\npublic final class PreferencesActivity extends Activity {\n\n  public static final String KEY_DECODE_1D_PRODUCT = \"preferences_decode_1D_product\";\n  public static final String KEY_DECODE_1D_INDUSTRIAL = \"preferences_decode_1D_industrial\";\n  public static final String KEY_DECODE_QR = \"preferences_decode_QR\";\n  public static final String KEY_DECODE_DATA_MATRIX = \"preferences_decode_Data_Matrix\";\n  public static final String KEY_DECODE_AZTEC = \"preferences_decode_Aztec\";\n  public static final String KEY_DECODE_PDF417 = \"preferences_decode_PDF417\";\n\n  public static final String KEY_CUSTOM_PRODUCT_SEARCH = \"preferences_custom_product_search\";\n\n  public static final String KEY_PLAY_BEEP = \"preferences_play_beep\";\n  public static final String KEY_VIBRATE = \"preferences_vibrate\";\n  public static final String KEY_COPY_TO_CLIPBOARD = \"preferences_copy_to_clipboard\";\n  public static final String KEY_FRONT_LIGHT_MODE = \"preferences_front_light_mode\";\n  public static final String KEY_BULK_MODE = \"preferences_bulk_mode\";\n  public static final String KEY_REMEMBER_DUPLICATES = \"preferences_remember_duplicates\";\n  public static final String KEY_ENABLE_HISTORY = \"preferences_history\";\n  public static final String KEY_SUPPLEMENTAL = \"preferences_supplemental\";\n  public static final String KEY_AUTO_FOCUS = \"preferences_auto_focus\";\n  public static final String KEY_INVERT_SCAN = \"preferences_invert_scan\";  \n  public static final String KEY_SEARCH_COUNTRY = \"preferences_search_country\";\n  public static final String KEY_DISABLE_AUTO_ORIENTATION = \"preferences_orientation\";\n\n  public static final String KEY_DISABLE_CONTINUOUS_FOCUS = \"preferences_disable_continuous_focus\";\n  public static final String KEY_DISABLE_EXPOSURE = \"preferences_disable_exposure\";\n  public static final String KEY_DISABLE_METERING = \"preferences_disable_metering\";\n  public static final String KEY_DISABLE_BARCODE_SCENE_MODE = \"preferences_disable_barcode_scene_mode\";\n  public static final String KEY_AUTO_OPEN_WEB = \"preferences_auto_open_web\";\n\n  @Override\n  protected void onCreate(Bundle icicle) {\n    super.onCreate(icicle);\n    getFragmentManager().beginTransaction().replace(android.R.id.content, new PreferencesFragment()).commit();\n  }\n\n  // Apparently this will be necessary when targeting API 19+:\n  /*\n  @Override\n  protected boolean isValidFragment(String fragmentName) {\n    return true;\n  }\n   */\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- qrcode/src/main/java/com/google/zxing/client/android/PreferencesActivity.java	(date 1545458417000)
+++ qrcode/src/main/java/com/google/zxing/client/android/PreferencesActivity.java	(revision )
@@ -47,7 +47,6 @@
   public static final String KEY_AUTO_FOCUS = "preferences_auto_focus";
   public static final String KEY_INVERT_SCAN = "preferences_invert_scan";  
   public static final String KEY_SEARCH_COUNTRY = "preferences_search_country";
-  public static final String KEY_DISABLE_AUTO_ORIENTATION = "preferences_orientation";
 
   public static final String KEY_DISABLE_CONTINUOUS_FOCUS = "preferences_disable_continuous_focus";
   public static final String KEY_DISABLE_EXPOSURE = "preferences_disable_exposure";
Index: qrcode/src/main/java/com/google/zxing/client/android/camera/AutoFocusManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * Copyright (C) 2012 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.zxing.client.android.camera;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.hardware.Camera;\nimport android.os.AsyncTask;\nimport android.preference.PreferenceManager;\nimport android.util.Log;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.concurrent.RejectedExecutionException;\n\nimport com.google.zxing.client.android.PreferencesActivity;\n\n@SuppressWarnings(\"deprecation\") // camera APIs\nfinal class AutoFocusManager implements Camera.AutoFocusCallback {\n\n    private static final String TAG = AutoFocusManager.class.getSimpleName();\n\n    private static final long AUTO_FOCUS_INTERVAL_MS = 2000L;\n    private static final Collection<String> FOCUS_MODES_CALLING_AF;\n\n    static {\n        FOCUS_MODES_CALLING_AF = new ArrayList<>(2);\n        FOCUS_MODES_CALLING_AF.add(Camera.Parameters.FOCUS_MODE_AUTO);\n        FOCUS_MODES_CALLING_AF.add(Camera.Parameters.FOCUS_MODE_MACRO);\n    }\n\n    private boolean stopped;\n    private boolean focusing;\n    private final boolean useAutoFocus;\n    private final Camera camera;\n    private AsyncTask<?, ?, ?> outstandingTask;\n\n    AutoFocusManager(Context context, Camera camera) {\n        this.camera = camera;\n        SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(context);\n        String currentFocusMode = camera.getParameters().getFocusMode();\n        useAutoFocus =\n                sharedPrefs.getBoolean(PreferencesActivity.KEY_AUTO_FOCUS, true) &&\n                        FOCUS_MODES_CALLING_AF.contains(currentFocusMode);\n        Log.i(TAG, \"Current focus mode '\" + currentFocusMode + \"'; use auto focus? \" + useAutoFocus);\n        start();\n    }\n\n    @Override\n    public synchronized void onAutoFocus(boolean success, Camera theCamera) {\n        focusing = false;\n        autoFocusAgainLater();\n    }\n\n    private synchronized void autoFocusAgainLater() {\n        if (!stopped && outstandingTask == null) {\n            AutoFocusTask newTask = new AutoFocusTask();\n            try {\n                newTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);\n                outstandingTask = newTask;\n            } catch (RejectedExecutionException ree) {\n                Log.w(TAG, \"Could not request auto focus\", ree);\n            }\n        }\n    }\n\n    synchronized void start() {\n        if (useAutoFocus) {\n            outstandingTask = null;\n            if (!stopped && !focusing) {\n                try {\n                    camera.autoFocus(this);\n                    focusing = true;\n                } catch (RuntimeException re) {\n                    // Have heard RuntimeException reported in Android 4.0.x+; continue?\n                    Log.w(TAG, \"Unexpected exception while focusing\", re);\n                    // Try again later to keep cycle going\n                    autoFocusAgainLater();\n                }\n            }\n        }\n    }\n\n    private synchronized void cancelOutstandingTask() {\n        if (outstandingTask != null) {\n            if (outstandingTask.getStatus() != AsyncTask.Status.FINISHED) {\n                outstandingTask.cancel(true);\n            }\n            outstandingTask = null;\n        }\n    }\n\n    synchronized void stop() {\n        stopped = true;\n        if (useAutoFocus) {\n            cancelOutstandingTask();\n            // Doesn't hurt to call this even if not focusing\n            try {\n                camera.cancelAutoFocus();\n            } catch (RuntimeException re) {\n                // Have heard RuntimeException reported in Android 4.0.x+; continue?\n                Log.w(TAG, \"Unexpected exception while cancelling focusing\", re);\n            }\n        }\n    }\n\n    private final class AutoFocusTask extends AsyncTask<Object, Object, Object> {\n        @Override\n        protected Object doInBackground(Object... voids) {\n            try {\n                Thread.sleep(AUTO_FOCUS_INTERVAL_MS);\n            } catch (InterruptedException e) {\n                // continue\n            }\n            start();\n            return null;\n        }\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- qrcode/src/main/java/com/google/zxing/client/android/camera/AutoFocusManager.java	(date 1545458417000)
+++ qrcode/src/main/java/com/google/zxing/client/android/camera/AutoFocusManager.java	(revision )
@@ -23,18 +23,18 @@
 import android.preference.PreferenceManager;
 import android.util.Log;
 
+import com.google.zxing.client.android.PreferencesActivity;
+
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.concurrent.RejectedExecutionException;
 
-import com.google.zxing.client.android.PreferencesActivity;
-
 @SuppressWarnings("deprecation") // camera APIs
 final class AutoFocusManager implements Camera.AutoFocusCallback {
 
     private static final String TAG = AutoFocusManager.class.getSimpleName();
 
-    private static final long AUTO_FOCUS_INTERVAL_MS = 2000L;
+    private static final long AUTO_FOCUS_INTERVAL_MS = 1000L;//自动聚焦时长
     private static final Collection<String> FOCUS_MODES_CALLING_AF;
 
     static {
Index: qrcode/src/main/java/com/google/zxing/client/android/camera/CameraManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * Copyright (C) 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.zxing.client.android.camera;\n\nimport android.content.Context;\nimport android.graphics.Point;\nimport android.graphics.Rect;\nimport android.hardware.Camera;\nimport android.os.Handler;\nimport android.util.Log;\nimport android.view.SurfaceHolder;\n\nimport com.google.zxing.PlanarYUVLuminanceSource;\nimport com.google.zxing.client.android.camera.open.OpenCamera;\nimport com.google.zxing.client.android.camera.open.OpenCameraInterface;\n\nimport java.io.IOException;\n\n/**\n * This object wraps the Camera service object and expects to be the only one talking to it. The\n * implementation encapsulates the steps needed to take preview-sized images, which are used for\n * both preview and decoding.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\n@SuppressWarnings(\"deprecation\") // camera APIs\npublic final class CameraManager {\n\n    private static final String TAG = CameraManager.class.getSimpleName();\n\n    private static final int MIN_FRAME_WIDTH = 240;\n    private static final int MIN_FRAME_HEIGHT = 240;\n    private static final int MAX_FRAME_WIDTH = 1200; // = 5/8 * 1920\n    private static final int MAX_FRAME_HEIGHT = 675; // = 5/8 * 1080\n\n    private final Context context;\n    private final CameraConfigurationManager configManager;\n    private OpenCamera camera;\n    private AutoFocusManager autoFocusManager;\n    private Rect framingRect;\n    private Rect framingRectInPreview;\n    private boolean initialized;\n    private boolean previewing;\n    private int requestedCameraId = OpenCameraInterface.NO_REQUESTED_CAMERA;\n    private int requestedFramingRectWidth;\n    private int requestedFramingRectHeight;\n    /**\n     * Preview frames are delivered here, which we pass on to the registered handler. Make sure to\n     * clear the handler so it will only receive one message.\n     */\n    private final PreviewCallback previewCallback;\n\n    public CameraManager(Context context) {\n        this.context = context;\n        this.configManager = new CameraConfigurationManager(context);\n        previewCallback = new PreviewCallback(configManager);\n    }\n\n    /**\n     * Opens the camera driver and initializes the hardware parameters.\n     *\n     * @param holder The surface object which the camera will draw preview frames into.\n     * @throws IOException Indicates the camera driver failed to open.\n     */\n    public synchronized void openDriver(SurfaceHolder holder) throws IOException {\n        OpenCamera theCamera = camera;\n        if (theCamera == null) {\n            theCamera = OpenCameraInterface.open(requestedCameraId);\n            if (theCamera == null) {\n                throw new IOException(\"Camera.open() failed to return object from driver\");\n            }\n            camera = theCamera;\n        }\n\n        if (!initialized) {\n            initialized = true;\n            configManager.initFromCameraParameters(theCamera);\n            if (requestedFramingRectWidth > 0 && requestedFramingRectHeight > 0) {\n                setManualFramingRect(requestedFramingRectWidth, requestedFramingRectHeight);\n                requestedFramingRectWidth = 0;\n                requestedFramingRectHeight = 0;\n            }\n        }\n\n        Camera cameraObject = theCamera.getCamera();\n        Camera.Parameters parameters = cameraObject.getParameters();\n        String parametersFlattened = parameters == null ? null : parameters.flatten(); // Save these, temporarily\n        try {\n            configManager.setDesiredCameraParameters(theCamera, false);\n        } catch (RuntimeException re) {\n            // Driver failed\n            Log.w(TAG, \"Camera rejected parameters. Setting only minimal safe-mode parameters\");\n            Log.i(TAG, \"Resetting to saved camera params: \" + parametersFlattened);\n            // Reset:\n            if (parametersFlattened != null) {\n                parameters = cameraObject.getParameters();\n                parameters.unflatten(parametersFlattened);\n                try {\n                    cameraObject.setParameters(parameters);\n                    configManager.setDesiredCameraParameters(theCamera, true);\n                } catch (RuntimeException re2) {\n                    // Well, darn. Give up\n                    Log.w(TAG, \"Camera rejected even safe-mode parameters! No configuration\");\n                }\n            }\n        }\n        cameraObject.setPreviewDisplay(holder);\n\n    }\n\n    public synchronized boolean isOpen() {\n        return camera != null;\n    }\n\n    /**\n     * Closes the camera driver if still in use.\n     */\n    public synchronized void closeDriver() {\n        if (camera != null) {\n            camera.getCamera().release();\n            camera = null;\n            // Make sure to clear these each time we close the camera, so that any scanning rect\n            // requested by intent is forgotten.\n            framingRect = null;\n            framingRectInPreview = null;\n        }\n    }\n\n    /**\n     * Asks the camera hardware to begin drawing preview frames to the screen.\n     */\n    public synchronized void startPreview() {\n        OpenCamera theCamera = camera;\n        if (theCamera != null && !previewing) {\n            theCamera.getCamera().startPreview();\n            previewing = true;\n            autoFocusManager = new AutoFocusManager(context, theCamera.getCamera());\n        }\n    }\n\n    /**\n     * Tells the camera to stop drawing preview frames.\n     */\n    public synchronized void stopPreview() {\n        if (autoFocusManager != null) {\n            autoFocusManager.stop();\n            autoFocusManager = null;\n        }\n        if (camera != null && previewing) {\n            camera.getCamera().stopPreview();\n            previewCallback.setHandler(null, 0);\n            previewing = false;\n        }\n    }\n\n    /**\n     * Convenience method for {@link com.google.zxing.client.android.CaptureActivity}\n     *\n     * @param newSetting if {@code true}, light should be turned on if currently off. And vice versa.\n     */\n    public synchronized void setTorch(boolean newSetting) {\n        OpenCamera theCamera = camera;\n        if (theCamera != null && newSetting != configManager.getTorchState(theCamera.getCamera())) {\n            boolean wasAutoFocusManager = autoFocusManager != null;\n            if (wasAutoFocusManager) {\n                autoFocusManager.stop();\n                autoFocusManager = null;\n            }\n            configManager.setTorch(theCamera.getCamera(), newSetting);\n            if (wasAutoFocusManager) {\n                autoFocusManager = new AutoFocusManager(context, theCamera.getCamera());\n                autoFocusManager.start();\n            }\n        }\n    }\n\n    /**\n     * A single preview frame will be returned to the handler supplied. The data will arrive as byte[]\n     * in the message.obj field, with width and height encoded as message.arg1 and message.arg2,\n     * respectively.\n     *\n     * @param handler The handler to send the message to.\n     * @param message The what field of the message to be sent.\n     */\n    public synchronized void requestPreviewFrame(Handler handler, int message) {\n        OpenCamera theCamera = camera;\n        if (theCamera != null && previewing) {\n            previewCallback.setHandler(handler, message);\n            theCamera.getCamera().setOneShotPreviewCallback(previewCallback);\n        }\n    }\n\n    /**\n     * Calculates the framing rect which the UI should draw to show the user where to place the\n     * barcode. This target helps with alignment as well as forces the user to hold the device\n     * far enough away to ensure the image will be in focus.\n     *\n     * @return The rectangle to draw on screen in window coordinates.\n     */\n    public synchronized Rect getFramingRect() {\n        if (framingRect == null) {\n            if (camera == null) {\n                return null;\n            }\n            Point screenResolution = configManager.getScreenResolution();\n            if (screenResolution == null) {\n                // Called early, before init even finished\n                return null;\n            }\n\n            int width = findDesiredDimensionInRange(screenResolution.x, MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);\n            int height = findDesiredDimensionInRange(screenResolution.y, MIN_FRAME_HEIGHT, MAX_FRAME_HEIGHT);\n\n            int leftOffset = (screenResolution.x - width) / 2;\n            int topOffset = (screenResolution.y - height) / 2;\n            framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);\n            Log.d(TAG, \"Calculated framing rect: \" + framingRect);\n        }\n        return framingRect;\n    }\n\n    private static int findDesiredDimensionInRange(int resolution, int hardMin, int hardMax) {\n        int dim = 5 * resolution / 8; // Target 5/8 of each dimension\n        if (dim < hardMin) {\n            return hardMin;\n        }\n        if (dim > hardMax) {\n            return hardMax;\n        }\n        return dim;\n    }\n\n    /**\n     * Like {@link #getFramingRect} but coordinates are in terms of the preview frame,\n     * not UI / screen.\n     *\n     * @return {@link Rect} expressing barcode scan area in terms of the preview size\n     */\n    public synchronized Rect getFramingRectInPreview() {\n        if (framingRectInPreview == null) {\n            Rect framingRect = getFramingRect();\n            if (framingRect == null) {\n                return null;\n            }\n            Rect rect = new Rect(framingRect);\n            Point cameraResolution = configManager.getCameraResolution();\n            Point screenResolution = configManager.getScreenResolution();\n            if (cameraResolution == null || screenResolution == null) {\n                // Called early, before init even finished\n                return null;\n            }\n            rect.left = rect.left * cameraResolution.x / screenResolution.x;\n            rect.right = rect.right * cameraResolution.x / screenResolution.x;\n            rect.top = rect.top * cameraResolution.y / screenResolution.y;\n            rect.bottom = rect.bottom * cameraResolution.y / screenResolution.y;\n            framingRectInPreview = rect;\n        }\n        return framingRectInPreview;\n    }\n\n\n    /**\n     * Allows third party apps to specify the camera ID, rather than determine\n     * it automatically based on available cameras and their orientation.\n     *\n     * @param cameraId camera ID of the camera to use. A negative value means \"no preference\".\n     */\n    public synchronized void setManualCameraId(int cameraId) {\n        requestedCameraId = cameraId;\n    }\n\n    /**\n     * Allows third party apps to specify the scanning rectangle dimensions, rather than determine\n     * them automatically based on screen resolution.\n     *\n     * @param width  The width in pixels to scan.\n     * @param height The height in pixels to scan.\n     */\n    public synchronized void setManualFramingRect(int width, int height) {\n        if (initialized) {\n            Point screenResolution = configManager.getScreenResolution();\n            if (width > screenResolution.x) {\n                width = screenResolution.x;\n            }\n            if (height > screenResolution.y) {\n                height = screenResolution.y;\n            }\n            int leftOffset = (screenResolution.x - width) / 2;\n            int topOffset = (screenResolution.y - height) / 2;\n            framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);\n            Log.d(TAG, \"Calculated manual framing rect: \" + framingRect);\n            framingRectInPreview = null;\n        } else {\n            requestedFramingRectWidth = width;\n            requestedFramingRectHeight = height;\n        }\n    }\n\n    /**\n     * A factory method to build the appropriate LuminanceSource object based on the format\n     * of the preview buffers, as described by Camera.Parameters.\n     *\n     * @param data   A preview frame.\n     * @param width  The width of the image.\n     * @param height The height of the image.\n     * @return A PlanarYUVLuminanceSource instance.\n     */\n    public PlanarYUVLuminanceSource buildLuminanceSource(byte[] data, int width, int height) {\n        Rect rect = getFramingRectInPreview();\n        if (rect == null) {\n            return null;\n        }\n        // Go ahead and assume it's YUV rather than die.\n        return new PlanarYUVLuminanceSource(data, width, height, rect.left, rect.top,\n                rect.width(), rect.height(), false);\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- qrcode/src/main/java/com/google/zxing/client/android/camera/CameraManager.java	(date 1545458417000)
+++ qrcode/src/main/java/com/google/zxing/client/android/camera/CameraManager.java	(revision )
@@ -44,8 +44,8 @@
 
     private static final int MIN_FRAME_WIDTH = 240;
     private static final int MIN_FRAME_HEIGHT = 240;
-    private static final int MAX_FRAME_WIDTH = 1200; // = 5/8 * 1920
-    private static final int MAX_FRAME_HEIGHT = 675; // = 5/8 * 1080
+    private static final int MAX_FRAME_WIDTH = 1440; // = 3/4 * 1920
+    private static final int MAX_FRAME_HEIGHT = 810; // = 3/4 * 1080
 
     private final Context context;
     private final CameraConfigurationManager configManager;
@@ -224,6 +224,11 @@
 
             int width = findDesiredDimensionInRange(screenResolution.x, MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);
             int height = findDesiredDimensionInRange(screenResolution.y, MIN_FRAME_HEIGHT, MAX_FRAME_HEIGHT);
+            Log.d(TAG, "getFramingRect width: " + width + ",height: " + height);
+            //取景框设为正方形
+            int min = Math.min(width, height);
+            width = min;
+            height = min;
 
             int leftOffset = (screenResolution.x - width) / 2;
             int topOffset = (screenResolution.y - height) / 2;
@@ -234,7 +239,7 @@
     }
 
     private static int findDesiredDimensionInRange(int resolution, int hardMin, int hardMax) {
-        int dim = 5 * resolution / 8; // Target 5/8 of each dimension
+        int dim = 3 * resolution / 4; // Target 3/4 of each dimension
         if (dim < hardMin) {
             return hardMin;
         }
Index: qrcode/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?><!--\n Copyright (C) 2008 ZXing authors\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n -->\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.google.zxing.client.android\"\n    android:installLocation=\"auto\"\n    android:versionCode=\"108\"\n    android:versionName=\"4.7.8\">\n\n    <uses-permission android:name=\"android.permission.CAMERA\" />\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.VIBRATE\" />\n    <uses-permission android:name=\"android.permission.FLASHLIGHT\" />\n    <uses-permission android:name=\"android.permission.READ_CONTACTS\" />\n    <!-- unavailable in API 23 -->\n    <uses-permission android:name=\"com.android.browser.permission.READ_HISTORY_BOOKMARKS\" />\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n    <uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\" />\n    <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n\n    <uses-sdk\n        android:minSdkVersion=\"19\"\n        android:targetSdkVersion=\"22\" />\n\n    <uses-feature android:name=\"android.hardware.camera.any\" />\n    <uses-feature\n        android:name=\"android.hardware.camera.autofocus\"\n        android:required=\"false\" />\n    <uses-feature\n        android:name=\"android.hardware.camera.flash\"\n        android:required=\"false\" />\n    <uses-feature android:name=\"android.hardware.screen.landscape\" />\n    <uses-feature\n        android:name=\"android.hardware.wifi\"\n        android:required=\"false\" />\n\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@drawable/launcher_icon\"\n        android:label=\"@string/app_name\"\n        android:logo=\"@drawable/launcher_icon\">\n        <activity\n            android:name=\".CaptureActivity\"\n            android:clearTaskOnLaunch=\"true\"\n            android:screenOrientation=\"sensorLandscape\"\n            android:stateNotNeeded=\"true\"\n            android:theme=\"@style/CaptureTheme\"\n            android:windowSoftInputMode=\"stateAlwaysHidden\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n            <intent-filter>\n                <action android:name=\"com.google.zxing.client.android.SCAN\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n            </intent-filter>\n            <!-- Allow web apps to launch Barcode Scanner by linking to http://zxing.appspot.com/scan. -->\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n\n                <data\n                    android:host=\"zxing.appspot.com\"\n                    android:path=\"/scan\"\n                    android:scheme=\"http\" />\n            </intent-filter>\n            <!-- We also support a Google Product Search URL. -->\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n\n                <data\n                    android:host=\"www.google.com\"\n                    android:path=\"/m/products/scan\"\n                    android:scheme=\"http\" />\n            </intent-filter>\n            <!-- And the UK version. -->\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n\n                <data\n                    android:host=\"www.google.co.uk\"\n                    android:path=\"/m/products/scan\"\n                    android:scheme=\"http\" />\n            </intent-filter>\n            <!-- Support zxing://scan/?... like iPhone app -->\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n\n                <data\n                    android:host=\"scan\"\n                    android:path=\"/\"\n                    android:scheme=\"zxing\" />\n            </intent-filter>\n        </activity>\n        <activity\n            android:name=\".PreferencesActivity\"\n            android:label=\"@string/preferences_name\"\n            android:stateNotNeeded=\"true\" />\n        <activity\n            android:name=\".encode.EncodeActivity\"\n            android:stateNotNeeded=\"true\">\n            <intent-filter>\n                <action android:name=\"com.google.zxing.client.android.ENCODE\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n            </intent-filter>\n            <!-- This allows us to handle the Share button in Contacts. -->\n            <intent-filter>\n                <action android:name=\"android.intent.action.SEND\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <data android:mimeType=\"text/x-vcard\" />\n            </intent-filter>\n            <!-- This allows us to handle sharing any plain text . -->\n            <intent-filter>\n                <action android:name=\"android.intent.action.SEND\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <data android:mimeType=\"text/plain\" />\n            </intent-filter>\n        </activity>\n        <activity\n            android:name=\".book.SearchBookContentsActivity\"\n            android:label=\"@string/sbc_name\"\n            android:screenOrientation=\"sensorLandscape\"\n            android:stateNotNeeded=\"true\">\n            <intent-filter>\n                <action android:name=\"com.google.zxing.client.android.SEARCH_BOOK_CONTENTS\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n            </intent-filter>\n        </activity>\n        <activity\n            android:name=\".share.ShareActivity\"\n            android:screenOrientation=\"user\"\n            android:stateNotNeeded=\"true\">\n            <intent-filter>\n                <action android:name=\"com.google.zxing.client.android.SHARE\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n            </intent-filter>\n        </activity>\n        <activity\n            android:name=\".share.BookmarkPickerActivity\"\n            android:label=\"@string/bookmark_picker_name\"\n            android:stateNotNeeded=\"true\" />\n        <activity\n            android:name=\".share.AppPickerActivity\"\n            android:label=\"@string/app_picker_name\"\n            android:stateNotNeeded=\"true\" />\n    </application>\n\n</manifest>\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- qrcode/src/main/AndroidManifest.xml	(date 1545458417000)
+++ qrcode/src/main/AndroidManifest.xml	(revision )
@@ -30,10 +30,6 @@
     <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
     <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
 
-    <uses-sdk
-        android:minSdkVersion="19"
-        android:targetSdkVersion="22" />
-
     <uses-feature android:name="android.hardware.camera.any" />
     <uses-feature
         android:name="android.hardware.camera.autofocus"
@@ -54,7 +50,6 @@
         <activity
             android:name=".CaptureActivity"
             android:clearTaskOnLaunch="true"
-            android:screenOrientation="sensorLandscape"
             android:stateNotNeeded="true"
             android:theme="@style/CaptureTheme"
             android:windowSoftInputMode="stateAlwaysHidden">
Index: qrcode/src/main/java/com/google/zxing/client/android/CaptureActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * Copyright (C) 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.zxing.client.android;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.preference.PreferenceManager;\nimport android.util.Log;\nimport android.util.TypedValue;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.Surface;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.google.zxing.BarcodeFormat;\nimport com.google.zxing.DecodeHintType;\nimport com.google.zxing.Result;\nimport com.google.zxing.ResultMetadataType;\nimport com.google.zxing.ResultPoint;\nimport com.google.zxing.client.android.camera.CameraManager;\nimport com.google.zxing.client.android.clipboard.ClipboardInterface;\nimport com.google.zxing.client.android.history.HistoryItem;\nimport com.google.zxing.client.android.history.HistoryManager;\nimport com.google.zxing.client.android.result.ResultButtonListener;\nimport com.google.zxing.client.android.result.ResultHandler;\nimport com.google.zxing.client.android.result.ResultHandlerFactory;\nimport com.google.zxing.client.android.result.supplement.SupplementalInfoRetriever;\nimport com.google.zxing.client.android.share.ShareActivity;\n\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.util.Collection;\nimport java.util.EnumSet;\nimport java.util.Map;\n\n/**\n * This activity opens the camera and does the actual scanning on a background thread. It draws a\n * viewfinder to help the user place the barcode correctly, shows feedback as the image processing\n * is happening, and then overlays the results when a scan is successful.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n */\npublic final class CaptureActivity extends Activity implements SurfaceHolder.Callback {\n\n    private static final String TAG = CaptureActivity.class.getSimpleName();\n\n    private static final long DEFAULT_INTENT_RESULT_DURATION_MS = 1500L;\n    private static final long BULK_MODE_SCAN_DELAY_MS = 1000L;\n\n    private static final String[] ZXING_URLS = {\"http://zxing.appspot.com/scan\", \"zxing://scan/\"};\n\n    private static final int HISTORY_REQUEST_CODE = 0x0000bacc;\n\n    private static final Collection<ResultMetadataType> DISPLAYABLE_METADATA_TYPES =\n            EnumSet.of(ResultMetadataType.ISSUE_NUMBER,\n                    ResultMetadataType.SUGGESTED_PRICE,\n                    ResultMetadataType.ERROR_CORRECTION_LEVEL,\n                    ResultMetadataType.POSSIBLE_COUNTRY);\n\n    private CameraManager cameraManager;\n    private CaptureActivityHandler handler;\n    private Result savedResultToShow;\n    private ViewfinderView viewfinderView;\n    private TextView statusView;\n    private View resultView;\n    private Result lastResult;\n    private boolean hasSurface;\n    private boolean copyToClipboard;\n    private IntentSource source;\n    private String sourceUrl;\n    private ScanFromWebPageManager scanFromWebPageManager;\n    private Collection<BarcodeFormat> decodeFormats;\n    private Map<DecodeHintType, ?> decodeHints;\n    private String characterSet;\n    private HistoryManager historyManager;\n    private InactivityTimer inactivityTimer;\n    private BeepManager beepManager;\n    private AmbientLightManager ambientLightManager;\n\n    ViewfinderView getViewfinderView() {\n        return viewfinderView;\n    }\n\n    public Handler getHandler() {\n        return handler;\n    }\n\n    CameraManager getCameraManager() {\n        return cameraManager;\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n\n        Window window = getWindow();\n        window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n        setContentView(R.layout.capture);\n\n        hasSurface = false;\n        inactivityTimer = new InactivityTimer(this);\n        beepManager = new BeepManager(this);\n        ambientLightManager = new AmbientLightManager(this);\n\n        PreferenceManager.setDefaultValues(this, R.xml.preferences, false);\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n\n        // historyManager must be initialized here to update the history preference\n        historyManager = new HistoryManager(this);\n        historyManager.trimHistory();\n\n        // CameraManager must be initialized here, not in onCreate(). This is necessary because we don't\n        // want to open the camera driver and measure the screen size if we're going to show the help on\n        // first launch. That led to bugs where the scanning rectangle was the wrong size and partially\n        // off screen.\n        cameraManager = new CameraManager(getApplication());\n\n        viewfinderView = (ViewfinderView) findViewById(R.id.viewfinder_view);\n        viewfinderView.setCameraManager(cameraManager);\n\n        resultView = findViewById(R.id.result_view);\n        statusView = (TextView) findViewById(R.id.status_view);\n\n        handler = null;\n        lastResult = null;\n\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);\n\n        if (prefs.getBoolean(PreferencesActivity.KEY_DISABLE_AUTO_ORIENTATION, true)) {\n            setRequestedOrientation(getCurrentOrientation());\n        } else {\n            setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE);\n        }\n\n        resetStatusView();\n\n\n        beepManager.updatePrefs();\n        ambientLightManager.start(cameraManager);\n\n        inactivityTimer.onResume();\n\n        Intent intent = getIntent();\n\n        copyToClipboard = prefs.getBoolean(PreferencesActivity.KEY_COPY_TO_CLIPBOARD, true)\n                && (intent == null || intent.getBooleanExtra(Intents.Scan.SAVE_HISTORY, true));\n\n        source = IntentSource.NONE;\n        sourceUrl = null;\n        scanFromWebPageManager = null;\n        decodeFormats = null;\n        characterSet = null;\n\n        if (intent != null) {\n\n            String action = intent.getAction();\n            String dataString = intent.getDataString();\n\n            if (Intents.Scan.ACTION.equals(action)) {\n\n                // Scan the formats the intent requested, and return the result to the calling activity.\n                source = IntentSource.NATIVE_APP_INTENT;\n                decodeFormats = DecodeFormatManager.parseDecodeFormats(intent);\n                decodeHints = DecodeHintManager.parseDecodeHints(intent);\n\n                if (intent.hasExtra(Intents.Scan.WIDTH) && intent.hasExtra(Intents.Scan.HEIGHT)) {\n                    int width = intent.getIntExtra(Intents.Scan.WIDTH, 0);\n                    int height = intent.getIntExtra(Intents.Scan.HEIGHT, 0);\n                    if (width > 0 && height > 0) {\n                        cameraManager.setManualFramingRect(width, height);\n                    }\n                }\n\n                if (intent.hasExtra(Intents.Scan.CAMERA_ID)) {\n                    int cameraId = intent.getIntExtra(Intents.Scan.CAMERA_ID, -1);\n                    if (cameraId >= 0) {\n                        cameraManager.setManualCameraId(cameraId);\n                    }\n                }\n\n                String customPromptMessage = intent.getStringExtra(Intents.Scan.PROMPT_MESSAGE);\n                if (customPromptMessage != null) {\n                    statusView.setText(customPromptMessage);\n                }\n\n            } else if (dataString != null &&\n                    dataString.contains(\"http://www.google\") &&\n                    dataString.contains(\"/m/products/scan\")) {\n\n                // Scan only products and send the result to mobile Product Search.\n                source = IntentSource.PRODUCT_SEARCH_LINK;\n                sourceUrl = dataString;\n                decodeFormats = DecodeFormatManager.PRODUCT_FORMATS;\n\n            } else if (isZXingURL(dataString)) {\n\n                // Scan formats requested in query string (all formats if none specified).\n                // If a return URL is specified, send the results there. Otherwise, handle it ourselves.\n                source = IntentSource.ZXING_LINK;\n                sourceUrl = dataString;\n                Uri inputUri = Uri.parse(dataString);\n                scanFromWebPageManager = new ScanFromWebPageManager(inputUri);\n                decodeFormats = DecodeFormatManager.parseDecodeFormats(inputUri);\n                // Allow a sub-set of the hints to be specified by the caller.\n                decodeHints = DecodeHintManager.parseDecodeHints(inputUri);\n\n            }\n\n            characterSet = intent.getStringExtra(Intents.Scan.CHARACTER_SET);\n\n        }\n\n        SurfaceView surfaceView = (SurfaceView) findViewById(R.id.preview_view);\n        SurfaceHolder surfaceHolder = surfaceView.getHolder();\n        if (hasSurface) {\n            // The activity was paused but not stopped, so the surface still exists. Therefore\n            // surfaceCreated() won't be called, so init the camera here.\n            initCamera(surfaceHolder);\n        } else {\n            // Install the callback and wait for surfaceCreated() to init the camera.\n            surfaceHolder.addCallback(this);\n        }\n    }\n\n    private int getCurrentOrientation() {\n        int rotation = getWindowManager().getDefaultDisplay().getRotation();\n        if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {\n            switch (rotation) {\n                case Surface.ROTATION_0:\n                case Surface.ROTATION_90:\n                    return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;\n                default:\n                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;\n            }\n        } else {\n            switch (rotation) {\n                case Surface.ROTATION_0:\n                case Surface.ROTATION_270:\n                    return ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;\n                default:\n                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;\n            }\n        }\n    }\n\n    private static boolean isZXingURL(String dataString) {\n        if (dataString == null) {\n            return false;\n        }\n        for (String url : ZXING_URLS) {\n            if (dataString.startsWith(url)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    protected void onPause() {\n        if (handler != null) {\n            handler.quitSynchronously();\n            handler = null;\n        }\n        inactivityTimer.onPause();\n        ambientLightManager.stop();\n        beepManager.close();\n        cameraManager.closeDriver();\n        //historyManager = null; // Keep for onActivityResult\n        if (!hasSurface) {\n            SurfaceView surfaceView = (SurfaceView) findViewById(R.id.preview_view);\n            SurfaceHolder surfaceHolder = surfaceView.getHolder();\n            surfaceHolder.removeCallback(this);\n        }\n        super.onPause();\n    }\n\n    @Override\n    protected void onDestroy() {\n        inactivityTimer.shutdown();\n        super.onDestroy();\n    }\n\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event) {\n        switch (keyCode) {\n            case KeyEvent.KEYCODE_BACK:\n                if (source == IntentSource.NATIVE_APP_INTENT) {\n                    setResult(RESULT_CANCELED);\n                    finish();\n                    return true;\n                }\n                if ((source == IntentSource.NONE || source == IntentSource.ZXING_LINK) && lastResult != null) {\n                    restartPreviewAfterDelay(0L);\n                    return true;\n                }\n                break;\n            case KeyEvent.KEYCODE_FOCUS:\n            case KeyEvent.KEYCODE_CAMERA:\n                // Handle these events so they don't launch the Camera app\n                return true;\n            // Use volume up/down to turn on light\n            case KeyEvent.KEYCODE_VOLUME_DOWN:\n                cameraManager.setTorch(false);\n                return true;\n            case KeyEvent.KEYCODE_VOLUME_UP:\n                cameraManager.setTorch(true);\n                return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        MenuInflater menuInflater = getMenuInflater();\n        menuInflater.inflate(R.menu.capture, menu);\n        return super.onCreateOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent = new Intent(Intent.ACTION_VIEW);\n        intent.addFlags(Intents.FLAG_NEW_DOC);\n        switch (item.getItemId()) {\n            case R.id.menu_share:\n                intent.setClassName(this, ShareActivity.class.getName());\n                startActivity(intent);\n                break;\n            case R.id.menu_settings:\n                intent.setClassName(this, PreferencesActivity.class.getName());\n                startActivity(intent);\n                break;\n            default:\n                return super.onOptionsItemSelected(item);\n        }\n        return true;\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        if (resultCode == RESULT_OK && requestCode == HISTORY_REQUEST_CODE && historyManager != null) {\n            int itemNumber = intent.getIntExtra(Intents.History.ITEM_NUMBER, -1);\n            if (itemNumber >= 0) {\n                HistoryItem historyItem = historyManager.buildHistoryItem(itemNumber);\n                decodeOrStoreSavedBitmap(null, historyItem.getResult());\n            }\n        }\n    }\n\n    private void decodeOrStoreSavedBitmap(Bitmap bitmap, Result result) {\n        // Bitmap isn't used yet -- will be used soon\n        if (handler == null) {\n            savedResultToShow = result;\n        } else {\n            if (result != null) {\n                savedResultToShow = result;\n            }\n            if (savedResultToShow != null) {\n                Message message = Message.obtain(handler, R.id.decode_succeeded, savedResultToShow);\n                handler.sendMessage(message);\n            }\n            savedResultToShow = null;\n        }\n    }\n\n    @Override\n    public void surfaceCreated(SurfaceHolder holder) {\n        if (holder == null) {\n            Log.e(TAG, \"*** WARNING *** surfaceCreated() gave us a null surface!\");\n        }\n        if (!hasSurface) {\n            hasSurface = true;\n            initCamera(holder);\n        }\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        hasSurface = false;\n    }\n\n    @Override\n    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {\n        // do nothing\n    }\n\n    /**\n     * A valid barcode has been found, so give an indication of success and show the results.\n     *\n     * @param rawResult   The contents of the barcode.\n     * @param scaleFactor amount by which thumbnail was scaled\n     * @param barcode     A greyscale bitmap of the camera data which was decoded.\n     */\n    public void handleDecode(Result rawResult, Bitmap barcode, float scaleFactor) {\n        inactivityTimer.onActivity();\n        lastResult = rawResult;\n        ResultHandler resultHandler = ResultHandlerFactory.makeResultHandler(this, rawResult);\n\n        boolean fromLiveScan = barcode != null;\n        if (fromLiveScan) {\n            historyManager.addHistoryItem(rawResult, resultHandler);\n            // Then not from history, so beep/vibrate and we have an image to draw on\n            beepManager.playBeepSoundAndVibrate();\n            drawResultPoints(barcode, scaleFactor, rawResult);\n        }\n\n        switch (source) {\n            case NATIVE_APP_INTENT:\n            case PRODUCT_SEARCH_LINK:\n                handleDecodeExternally(rawResult, resultHandler, barcode);\n                break;\n            case ZXING_LINK:\n                if (scanFromWebPageManager == null || !scanFromWebPageManager.isScanFromWebPage()) {\n                    handleDecodeInternally(rawResult, resultHandler, barcode);\n                } else {\n                    handleDecodeExternally(rawResult, resultHandler, barcode);\n                }\n                break;\n            case NONE:\n                SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);\n                if (fromLiveScan && prefs.getBoolean(PreferencesActivity.KEY_BULK_MODE, false)) {\n                    Toast.makeText(getApplicationContext(),\n                            getResources().getString(R.string.msg_bulk_mode_scanned) + \" (\" + rawResult.getText() + ')',\n                            Toast.LENGTH_SHORT).show();\n                    maybeSetClipboard(resultHandler);\n                    // Wait a moment or else it will scan the same barcode continuously about 3 times\n                    restartPreviewAfterDelay(BULK_MODE_SCAN_DELAY_MS);\n                } else {\n                    handleDecodeInternally(rawResult, resultHandler, barcode);\n                }\n                break;\n        }\n    }\n\n    /**\n     * Superimpose a line for 1D or dots for 2D to highlight the key features of the barcode.\n     *\n     * @param barcode     A bitmap of the captured image.\n     * @param scaleFactor amount by which thumbnail was scaled\n     * @param rawResult   The decoded results which contains the points to draw.\n     */\n    private void drawResultPoints(Bitmap barcode, float scaleFactor, Result rawResult) {\n        ResultPoint[] points = rawResult.getResultPoints();\n        if (points != null && points.length > 0) {\n            Canvas canvas = new Canvas(barcode);\n            Paint paint = new Paint();\n            paint.setColor(getResources().getColor(R.color.result_points));\n            if (points.length == 2) {\n                paint.setStrokeWidth(4.0f);\n                drawLine(canvas, paint, points[0], points[1], scaleFactor);\n            } else if (points.length == 4 &&\n                    (rawResult.getBarcodeFormat() == BarcodeFormat.UPC_A ||\n                            rawResult.getBarcodeFormat() == BarcodeFormat.EAN_13)) {\n                // Hacky special case -- draw two lines, for the barcode and metadata\n                drawLine(canvas, paint, points[0], points[1], scaleFactor);\n                drawLine(canvas, paint, points[2], points[3], scaleFactor);\n            } else {\n                paint.setStrokeWidth(10.0f);\n                for (ResultPoint point : points) {\n                    if (point != null) {\n                        canvas.drawPoint(scaleFactor * point.getX(), scaleFactor * point.getY(), paint);\n                    }\n                }\n            }\n        }\n    }\n\n    private static void drawLine(Canvas canvas, Paint paint, ResultPoint a, ResultPoint b, float scaleFactor) {\n        if (a != null && b != null) {\n            canvas.drawLine(scaleFactor * a.getX(),\n                    scaleFactor * a.getY(),\n                    scaleFactor * b.getX(),\n                    scaleFactor * b.getY(),\n                    paint);\n        }\n    }\n\n    // Put up our own UI for how to handle the decoded contents.\n    private void handleDecodeInternally(Result rawResult, ResultHandler resultHandler, Bitmap barcode) {\n\n        maybeSetClipboard(resultHandler);\n\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);\n\n        if (resultHandler.getDefaultButtonID() != null && prefs.getBoolean(PreferencesActivity.KEY_AUTO_OPEN_WEB, false)) {\n            resultHandler.handleButtonPress(resultHandler.getDefaultButtonID());\n            return;\n        }\n\n        statusView.setVisibility(View.GONE);\n        viewfinderView.setVisibility(View.GONE);\n        resultView.setVisibility(View.VISIBLE);\n\n        ImageView barcodeImageView = (ImageView) findViewById(R.id.barcode_image_view);\n        if (barcode == null) {\n            barcodeImageView.setImageBitmap(BitmapFactory.decodeResource(getResources(),\n                    R.drawable.launcher_icon));\n        } else {\n            barcodeImageView.setImageBitmap(barcode);\n        }\n\n        TextView formatTextView = (TextView) findViewById(R.id.format_text_view);\n        formatTextView.setText(rawResult.getBarcodeFormat().toString());\n\n        TextView typeTextView = (TextView) findViewById(R.id.type_text_view);\n        typeTextView.setText(resultHandler.getType().toString());\n\n        DateFormat formatter = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);\n        TextView timeTextView = (TextView) findViewById(R.id.time_text_view);\n        timeTextView.setText(formatter.format(rawResult.getTimestamp()));\n\n\n        TextView metaTextView = (TextView) findViewById(R.id.meta_text_view);\n        View metaTextViewLabel = findViewById(R.id.meta_text_view_label);\n        metaTextView.setVisibility(View.GONE);\n        metaTextViewLabel.setVisibility(View.GONE);\n        Map<ResultMetadataType, Object> metadata = rawResult.getResultMetadata();\n        if (metadata != null) {\n            StringBuilder metadataText = new StringBuilder(20);\n            for (Map.Entry<ResultMetadataType, Object> entry : metadata.entrySet()) {\n                if (DISPLAYABLE_METADATA_TYPES.contains(entry.getKey())) {\n                    metadataText.append(entry.getValue()).append('\\n');\n                }\n            }\n            if (metadataText.length() > 0) {\n                metadataText.setLength(metadataText.length() - 1);\n                metaTextView.setText(metadataText);\n                metaTextView.setVisibility(View.VISIBLE);\n                metaTextViewLabel.setVisibility(View.VISIBLE);\n            }\n        }\n\n        CharSequence displayContents = resultHandler.getDisplayContents();\n        TextView contentsTextView = (TextView) findViewById(R.id.contents_text_view);\n        contentsTextView.setText(displayContents);\n        int scaledSize = Math.max(22, 32 - displayContents.length() / 4);\n        contentsTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, scaledSize);\n\n        TextView supplementTextView = (TextView) findViewById(R.id.contents_supplement_text_view);\n        supplementTextView.setText(\"\");\n        supplementTextView.setOnClickListener(null);\n        if (PreferenceManager.getDefaultSharedPreferences(this).getBoolean(\n                PreferencesActivity.KEY_SUPPLEMENTAL, true)) {\n            SupplementalInfoRetriever.maybeInvokeRetrieval(supplementTextView,\n                    resultHandler.getResult(),\n                    historyManager,\n                    this);\n        }\n\n        int buttonCount = resultHandler.getButtonCount();\n        ViewGroup buttonView = (ViewGroup) findViewById(R.id.result_button_view);\n        buttonView.requestFocus();\n        for (int x = 0; x < ResultHandler.MAX_BUTTON_COUNT; x++) {\n            TextView button = (TextView) buttonView.getChildAt(x);\n            if (x < buttonCount) {\n                button.setVisibility(View.VISIBLE);\n                button.setText(resultHandler.getButtonText(x));\n                button.setOnClickListener(new ResultButtonListener(resultHandler, x));\n            } else {\n                button.setVisibility(View.GONE);\n            }\n        }\n\n    }\n\n    // Briefly show the contents of the barcode, then handle the result outside Barcode Scanner.\n    private void handleDecodeExternally(Result rawResult, ResultHandler resultHandler, Bitmap barcode) {\n\n        if (barcode != null) {\n            viewfinderView.drawResultBitmap(barcode);\n        }\n\n        long resultDurationMS;\n        if (getIntent() == null) {\n            resultDurationMS = DEFAULT_INTENT_RESULT_DURATION_MS;\n        } else {\n            resultDurationMS = getIntent().getLongExtra(Intents.Scan.RESULT_DISPLAY_DURATION_MS,\n                    DEFAULT_INTENT_RESULT_DURATION_MS);\n        }\n\n        if (resultDurationMS > 0) {\n            String rawResultString = String.valueOf(rawResult);\n            if (rawResultString.length() > 32) {\n                rawResultString = rawResultString.substring(0, 32) + \" ...\";\n            }\n            statusView.setText(getString(resultHandler.getDisplayTitle()) + \" : \" + rawResultString);\n        }\n\n        maybeSetClipboard(resultHandler);\n\n        switch (source) {\n            case NATIVE_APP_INTENT:\n                // Hand back whatever action they requested - this can be changed to Intents.Scan.ACTION when\n                // the deprecated intent is retired.\n                Intent intent = new Intent(getIntent().getAction());\n                intent.addFlags(Intents.FLAG_NEW_DOC);\n                intent.putExtra(Intents.Scan.RESULT, rawResult.toString());\n                intent.putExtra(Intents.Scan.RESULT_FORMAT, rawResult.getBarcodeFormat().toString());\n                byte[] rawBytes = rawResult.getRawBytes();\n                if (rawBytes != null && rawBytes.length > 0) {\n                    intent.putExtra(Intents.Scan.RESULT_BYTES, rawBytes);\n                }\n                Map<ResultMetadataType, ?> metadata = rawResult.getResultMetadata();\n                if (metadata != null) {\n                    if (metadata.containsKey(ResultMetadataType.UPC_EAN_EXTENSION)) {\n                        intent.putExtra(Intents.Scan.RESULT_UPC_EAN_EXTENSION,\n                                metadata.get(ResultMetadataType.UPC_EAN_EXTENSION).toString());\n                    }\n                    Number orientation = (Number) metadata.get(ResultMetadataType.ORIENTATION);\n                    if (orientation != null) {\n                        intent.putExtra(Intents.Scan.RESULT_ORIENTATION, orientation.intValue());\n                    }\n                    String ecLevel = (String) metadata.get(ResultMetadataType.ERROR_CORRECTION_LEVEL);\n                    if (ecLevel != null) {\n                        intent.putExtra(Intents.Scan.RESULT_ERROR_CORRECTION_LEVEL, ecLevel);\n                    }\n                    @SuppressWarnings(\"unchecked\")\n                    Iterable<byte[]> byteSegments = (Iterable<byte[]>) metadata.get(ResultMetadataType.BYTE_SEGMENTS);\n                    if (byteSegments != null) {\n                        int i = 0;\n                        for (byte[] byteSegment : byteSegments) {\n                            intent.putExtra(Intents.Scan.RESULT_BYTE_SEGMENTS_PREFIX + i, byteSegment);\n                            i++;\n                        }\n                    }\n                }\n                sendReplyMessage(R.id.return_scan_result, intent, resultDurationMS);\n                break;\n\n            case PRODUCT_SEARCH_LINK:\n                // Reformulate the URL which triggered us into a query, so that the request goes to the same\n                // TLD as the scan URL.\n                int end = sourceUrl.lastIndexOf(\"/scan\");\n                String productReplyURL = sourceUrl.substring(0, end) + \"?q=\" +\n                        resultHandler.getDisplayContents() + \"&source=zxing\";\n                sendReplyMessage(R.id.launch_product_query, productReplyURL, resultDurationMS);\n                break;\n\n            case ZXING_LINK:\n                if (scanFromWebPageManager != null && scanFromWebPageManager.isScanFromWebPage()) {\n                    String linkReplyURL = scanFromWebPageManager.buildReplyURL(rawResult, resultHandler);\n                    scanFromWebPageManager = null;\n                    sendReplyMessage(R.id.launch_product_query, linkReplyURL, resultDurationMS);\n                }\n                break;\n        }\n    }\n\n    private void maybeSetClipboard(ResultHandler resultHandler) {\n        if (copyToClipboard && !resultHandler.areContentsSecure()) {\n            ClipboardInterface.setText(resultHandler.getDisplayContents(), this);\n        }\n    }\n\n    private void sendReplyMessage(int id, Object arg, long delayMS) {\n        if (handler != null) {\n            Message message = Message.obtain(handler, id, arg);\n            if (delayMS > 0L) {\n                handler.sendMessageDelayed(message, delayMS);\n            } else {\n                handler.sendMessage(message);\n            }\n        }\n    }\n\n    private void initCamera(SurfaceHolder surfaceHolder) {\n        if (surfaceHolder == null) {\n            throw new IllegalStateException(\"No SurfaceHolder provided\");\n        }\n        if (cameraManager.isOpen()) {\n            Log.w(TAG, \"initCamera() while already open -- late SurfaceView callback?\");\n            return;\n        }\n        try {\n            cameraManager.openDriver(surfaceHolder);\n            // Creating the handler starts the preview, which can also throw a RuntimeException.\n            if (handler == null) {\n                handler = new CaptureActivityHandler(this, decodeFormats, decodeHints, characterSet, cameraManager);\n            }\n            decodeOrStoreSavedBitmap(null, null);\n        } catch (IOException ioe) {\n            Log.w(TAG, ioe);\n            displayFrameworkBugMessageAndExit();\n        } catch (RuntimeException e) {\n            // Barcode Scanner has seen crashes in the wild of this variety:\n            // java.?lang.?RuntimeException: Fail to connect to camera service\n            Log.w(TAG, \"Unexpected error initializing camera\", e);\n            displayFrameworkBugMessageAndExit();\n        }\n    }\n\n    private void displayFrameworkBugMessageAndExit() {\n        AlertDialog.Builder builder = new AlertDialog.Builder(this);\n        builder.setTitle(getString(R.string.app_name));\n        builder.setMessage(getString(R.string.msg_camera_framework_bug));\n        builder.setPositiveButton(R.string.button_ok, new FinishListener(this));\n        builder.setOnCancelListener(new FinishListener(this));\n        builder.show();\n    }\n\n    public void restartPreviewAfterDelay(long delayMS) {\n        if (handler != null) {\n            handler.sendEmptyMessageDelayed(R.id.restart_preview, delayMS);\n        }\n        resetStatusView();\n    }\n\n    private void resetStatusView() {\n        resultView.setVisibility(View.GONE);\n        statusView.setText(R.string.msg_default_status);\n        statusView.setVisibility(View.VISIBLE);\n        viewfinderView.setVisibility(View.VISIBLE);\n        lastResult = null;\n    }\n\n    public void drawViewfinder() {\n        viewfinderView.drawViewfinder();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- qrcode/src/main/java/com/google/zxing/client/android/CaptureActivity.java	(date 1545458417000)
+++ qrcode/src/main/java/com/google/zxing/client/android/CaptureActivity.java	(revision )
@@ -20,13 +20,10 @@
 import android.app.AlertDialog;
 import android.content.Intent;
 import android.content.SharedPreferences;
-import android.content.pm.ActivityInfo;
-import android.content.res.Configuration;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.graphics.Canvas;
 import android.graphics.Paint;
-import android.net.Uri;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.Message;
@@ -37,7 +34,6 @@
 import android.view.Menu;
 import android.view.MenuInflater;
 import android.view.MenuItem;
-import android.view.Surface;
 import android.view.SurfaceHolder;
 import android.view.SurfaceView;
 import android.view.View;
@@ -84,8 +80,6 @@
     private static final long DEFAULT_INTENT_RESULT_DURATION_MS = 1500L;
     private static final long BULK_MODE_SCAN_DELAY_MS = 1000L;
 
-    private static final String[] ZXING_URLS = {"http://zxing.appspot.com/scan", "zxing://scan/"};
-
     private static final int HISTORY_REQUEST_CODE = 0x0000bacc;
 
     private static final Collection<ResultMetadataType> DISPLAYABLE_METADATA_TYPES =
@@ -165,14 +159,6 @@
         handler = null;
         lastResult = null;
 
-        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
-
-        if (prefs.getBoolean(PreferencesActivity.KEY_DISABLE_AUTO_ORIENTATION, true)) {
-            setRequestedOrientation(getCurrentOrientation());
-        } else {
-            setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE);
-        }
-
         resetStatusView();
 
 
@@ -183,6 +169,7 @@
 
         Intent intent = getIntent();
 
+        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
         copyToClipboard = prefs.getBoolean(PreferencesActivity.KEY_COPY_TO_CLIPBOARD, true)
                 && (intent == null || intent.getBooleanExtra(Intents.Scan.SAVE_HISTORY, true));
 
@@ -224,27 +211,6 @@
                     statusView.setText(customPromptMessage);
                 }
 
-            } else if (dataString != null &&
-                    dataString.contains("http://www.google") &&
-                    dataString.contains("/m/products/scan")) {
-
-                // Scan only products and send the result to mobile Product Search.
-                source = IntentSource.PRODUCT_SEARCH_LINK;
-                sourceUrl = dataString;
-                decodeFormats = DecodeFormatManager.PRODUCT_FORMATS;
-
-            } else if (isZXingURL(dataString)) {
-
-                // Scan formats requested in query string (all formats if none specified).
-                // If a return URL is specified, send the results there. Otherwise, handle it ourselves.
-                source = IntentSource.ZXING_LINK;
-                sourceUrl = dataString;
-                Uri inputUri = Uri.parse(dataString);
-                scanFromWebPageManager = new ScanFromWebPageManager(inputUri);
-                decodeFormats = DecodeFormatManager.parseDecodeFormats(inputUri);
-                // Allow a sub-set of the hints to be specified by the caller.
-                decodeHints = DecodeHintManager.parseDecodeHints(inputUri);
-
             }
 
             characterSet = intent.getStringExtra(Intents.Scan.CHARACTER_SET);
@@ -263,39 +229,6 @@
         }
     }
 
-    private int getCurrentOrientation() {
-        int rotation = getWindowManager().getDefaultDisplay().getRotation();
-        if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
-            switch (rotation) {
-                case Surface.ROTATION_0:
-                case Surface.ROTATION_90:
-                    return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
-                default:
-                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
-            }
-        } else {
-            switch (rotation) {
-                case Surface.ROTATION_0:
-                case Surface.ROTATION_270:
-                    return ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
-                default:
-                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
-            }
-        }
-    }
-
-    private static boolean isZXingURL(String dataString) {
-        if (dataString == null) {
-            return false;
-        }
-        for (String url : ZXING_URLS) {
-            if (dataString.startsWith(url)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
     @Override
     protected void onPause() {
         if (handler != null) {
Index: qrcode/src/main/java/com/google/zxing/client/android/camera/CameraConfigurationManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * Copyright (C) 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.zxing.client.android.camera;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.graphics.Point;\nimport android.hardware.Camera;\nimport android.preference.PreferenceManager;\nimport android.util.Log;\nimport android.view.Display;\nimport android.view.Surface;\nimport android.view.WindowManager;\n\nimport com.google.zxing.client.android.PreferencesActivity;\nimport com.google.zxing.client.android.camera.open.CameraFacing;\nimport com.google.zxing.client.android.camera.open.OpenCamera;\n\n/**\n * A class which deals with reading, parsing, and setting the camera parameters which are used to\n * configure the camera hardware.\n */\n@SuppressWarnings(\"deprecation\") // camera APIs\nfinal class CameraConfigurationManager {\n\n    private static final String TAG = \"CameraConfiguration\";\n\n    private final Context context;\n    private int cwNeededRotation;\n    private int cwRotationFromDisplayToCamera;\n    private Point screenResolution;\n    private Point cameraResolution;\n    private Point bestPreviewSize;\n    private Point previewSizeOnScreen;\n\n    CameraConfigurationManager(Context context) {\n        this.context = context;\n    }\n\n    /**\n     * Reads, one time, values from the camera that are needed by the app.\n     */\n    void initFromCameraParameters(OpenCamera camera) {\n        Camera.Parameters parameters = camera.getCamera().getParameters();\n        WindowManager manager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);\n        Display display = manager.getDefaultDisplay();\n\n        int displayRotation = display.getRotation();\n        int cwRotationFromNaturalToDisplay;\n        switch (displayRotation) {\n            case Surface.ROTATION_0:\n                cwRotationFromNaturalToDisplay = 0;\n                break;\n            case Surface.ROTATION_90:\n                cwRotationFromNaturalToDisplay = 90;\n                break;\n            case Surface.ROTATION_180:\n                cwRotationFromNaturalToDisplay = 180;\n                break;\n            case Surface.ROTATION_270:\n                cwRotationFromNaturalToDisplay = 270;\n                break;\n            default:\n                // Have seen this return incorrect values like -90\n                if (displayRotation % 90 == 0) {\n                    cwRotationFromNaturalToDisplay = (360 + displayRotation) % 360;\n                } else {\n                    throw new IllegalArgumentException(\"Bad rotation: \" + displayRotation);\n                }\n        }\n        Log.i(TAG, \"Display at: \" + cwRotationFromNaturalToDisplay);\n\n        int cwRotationFromNaturalToCamera = camera.getOrientation();\n        Log.i(TAG, \"Camera at: \" + cwRotationFromNaturalToCamera);\n\n        // Still not 100% sure about this. But acts like we need to flip this:\n        if (camera.getFacing() == CameraFacing.FRONT) {\n            cwRotationFromNaturalToCamera = (360 - cwRotationFromNaturalToCamera) % 360;\n            Log.i(TAG, \"Front camera overriden to: \" + cwRotationFromNaturalToCamera);\n        }\n\n    /*\n    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);\n    String overrideRotationString;\n    if (camera.getFacing() == CameraFacing.FRONT) {\n      overrideRotationString = prefs.getString(PreferencesActivity.KEY_FORCE_CAMERA_ORIENTATION_FRONT, null);\n    } else {\n      overrideRotationString = prefs.getString(PreferencesActivity.KEY_FORCE_CAMERA_ORIENTATION, null);\n    }\n    if (overrideRotationString != null && !\"-\".equals(overrideRotationString)) {\n      Log.i(TAG, \"Overriding camera manually to \" + overrideRotationString);\n      cwRotationFromNaturalToCamera = Integer.parseInt(overrideRotationString);\n    }\n     */\n\n        cwRotationFromDisplayToCamera =\n                (360 + cwRotationFromNaturalToCamera - cwRotationFromNaturalToDisplay) % 360;\n        Log.i(TAG, \"Final display orientation: \" + cwRotationFromDisplayToCamera);\n        if (camera.getFacing() == CameraFacing.FRONT) {\n            Log.i(TAG, \"Compensating rotation for front camera\");\n            cwNeededRotation = (360 - cwRotationFromDisplayToCamera) % 360;\n        } else {\n            cwNeededRotation = cwRotationFromDisplayToCamera;\n        }\n        Log.i(TAG, \"Clockwise rotation from display to camera: \" + cwNeededRotation);\n\n        Point theScreenResolution = new Point();\n        display.getSize(theScreenResolution);\n        screenResolution = theScreenResolution;\n        Log.i(TAG, \"Screen resolution in current orientation: \" + screenResolution);\n        cameraResolution = CameraConfigurationUtils.findBestPreviewSizeValue(parameters, screenResolution);\n        Log.i(TAG, \"Camera resolution: \" + cameraResolution);\n        bestPreviewSize = CameraConfigurationUtils.findBestPreviewSizeValue(parameters, screenResolution);\n        Log.i(TAG, \"Best available preview size: \" + bestPreviewSize);\n\n        boolean isScreenPortrait = screenResolution.x < screenResolution.y;\n        boolean isPreviewSizePortrait = bestPreviewSize.x < bestPreviewSize.y;\n\n        if (isScreenPortrait == isPreviewSizePortrait) {\n            previewSizeOnScreen = bestPreviewSize;\n        } else {\n            previewSizeOnScreen = new Point(bestPreviewSize.y, bestPreviewSize.x);\n        }\n        Log.i(TAG, \"Preview size on screen: \" + previewSizeOnScreen);\n    }\n\n    void setDesiredCameraParameters(OpenCamera camera, boolean safeMode) {\n\n        Camera theCamera = camera.getCamera();\n        Camera.Parameters parameters = theCamera.getParameters();\n\n        if (parameters == null) {\n            Log.w(TAG, \"Device error: no camera parameters are available. Proceeding without configuration.\");\n            return;\n        }\n\n        Log.i(TAG, \"Initial camera parameters: \" + parameters.flatten());\n\n        if (safeMode) {\n            Log.w(TAG, \"In camera config safe mode -- most settings will not be honored\");\n        }\n\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);\n\n        initializeTorch(parameters, prefs, safeMode);\n\n        CameraConfigurationUtils.setFocus(\n                parameters,\n                prefs.getBoolean(PreferencesActivity.KEY_AUTO_FOCUS, true),\n                prefs.getBoolean(PreferencesActivity.KEY_DISABLE_CONTINUOUS_FOCUS, true),\n                safeMode);\n\n        if (!safeMode) {\n            if (prefs.getBoolean(PreferencesActivity.KEY_INVERT_SCAN, false)) {\n                CameraConfigurationUtils.setInvertColor(parameters);\n            }\n\n            if (!prefs.getBoolean(PreferencesActivity.KEY_DISABLE_BARCODE_SCENE_MODE, true)) {\n                CameraConfigurationUtils.setBarcodeSceneMode(parameters);\n            }\n\n            if (!prefs.getBoolean(PreferencesActivity.KEY_DISABLE_METERING, true)) {\n                CameraConfigurationUtils.setVideoStabilization(parameters);\n                CameraConfigurationUtils.setFocusArea(parameters);\n                CameraConfigurationUtils.setMetering(parameters);\n            }\n\n            //SetRecordingHint to true also a workaround for low framerate on Nexus 4\n            //https://stackoverflow.com/questions/14131900/extreme-camera-lag-on-nexus-4\n            parameters.setRecordingHint(true);\n\n        }\n\n        parameters.setPreviewSize(bestPreviewSize.x, bestPreviewSize.y);\n\n        theCamera.setParameters(parameters);\n\n        theCamera.setDisplayOrientation(cwRotationFromDisplayToCamera);\n\n        Camera.Parameters afterParameters = theCamera.getParameters();\n        Camera.Size afterSize = afterParameters.getPreviewSize();\n        if (afterSize != null && (bestPreviewSize.x != afterSize.width || bestPreviewSize.y != afterSize.height)) {\n            Log.w(TAG, \"Camera said it supported preview size \" + bestPreviewSize.x + 'x' + bestPreviewSize.y +\n                    \", but after setting it, preview size is \" + afterSize.width + 'x' + afterSize.height);\n            bestPreviewSize.x = afterSize.width;\n            bestPreviewSize.y = afterSize.height;\n        }\n    }\n\n    Point getBestPreviewSize() {\n        return bestPreviewSize;\n    }\n\n    Point getPreviewSizeOnScreen() {\n        return previewSizeOnScreen;\n    }\n\n    Point getCameraResolution() {\n        return cameraResolution;\n    }\n\n    Point getScreenResolution() {\n        return screenResolution;\n    }\n\n    int getCWNeededRotation() {\n        return cwNeededRotation;\n    }\n\n    boolean getTorchState(Camera camera) {\n        if (camera != null) {\n            Camera.Parameters parameters = camera.getParameters();\n            if (parameters != null) {\n                String flashMode = parameters.getFlashMode();\n                return\n                        Camera.Parameters.FLASH_MODE_ON.equals(flashMode) ||\n                                Camera.Parameters.FLASH_MODE_TORCH.equals(flashMode);\n            }\n        }\n        return false;\n    }\n\n    void setTorch(Camera camera, boolean newSetting) {\n        Camera.Parameters parameters = camera.getParameters();\n        doSetTorch(parameters, newSetting, false);\n        camera.setParameters(parameters);\n    }\n\n    private void initializeTorch(Camera.Parameters parameters, SharedPreferences prefs, boolean safeMode) {\n        boolean currentSetting = FrontLightMode.readPref(prefs) == FrontLightMode.ON;\n        doSetTorch(parameters, currentSetting, safeMode);\n    }\n\n    private void doSetTorch(Camera.Parameters parameters, boolean newSetting, boolean safeMode) {\n        CameraConfigurationUtils.setTorch(parameters, newSetting);\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);\n        if (!safeMode && !prefs.getBoolean(PreferencesActivity.KEY_DISABLE_EXPOSURE, true)) {\n            CameraConfigurationUtils.setBestExposure(parameters, newSetting);\n        }\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- qrcode/src/main/java/com/google/zxing/client/android/camera/CameraConfigurationManager.java	(date 1545458417000)
+++ qrcode/src/main/java/com/google/zxing/client/android/camera/CameraConfigurationManager.java	(revision )
@@ -33,6 +33,7 @@
 /**
  * A class which deals with reading, parsing, and setting the camera parameters which are used to
  * configure the camera hardware.
+ * 该类主要负责设置相机的参数信息，获取最佳的预览界面
  */
 @SuppressWarnings("deprecation") // camera APIs
 final class CameraConfigurationManager {
@@ -42,7 +43,9 @@
     private final Context context;
     private int cwNeededRotation;
     private int cwRotationFromDisplayToCamera;
+    //屏幕分辨率
     private Point screenResolution;
+    //相机分辨率
     private Point cameraResolution;
     private Point bestPreviewSize;
     private Point previewSizeOnScreen;
@@ -93,20 +96,6 @@
             Log.i(TAG, "Front camera overriden to: " + cwRotationFromNaturalToCamera);
         }
 
-    /*
-    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
-    String overrideRotationString;
-    if (camera.getFacing() == CameraFacing.FRONT) {
-      overrideRotationString = prefs.getString(PreferencesActivity.KEY_FORCE_CAMERA_ORIENTATION_FRONT, null);
-    } else {
-      overrideRotationString = prefs.getString(PreferencesActivity.KEY_FORCE_CAMERA_ORIENTATION, null);
-    }
-    if (overrideRotationString != null && !"-".equals(overrideRotationString)) {
-      Log.i(TAG, "Overriding camera manually to " + overrideRotationString);
-      cwRotationFromNaturalToCamera = Integer.parseInt(overrideRotationString);
-    }
-     */
-
         cwRotationFromDisplayToCamera =
                 (360 + cwRotationFromNaturalToCamera - cwRotationFromNaturalToDisplay) % 360;
         Log.i(TAG, "Final display orientation: " + cwRotationFromDisplayToCamera);
Index: qrcode/src/main/java/com/google/zxing/client/android/camera/CameraConfigurationUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * Copyright (C) 2014 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.zxing.client.android.camera;\n\nimport android.graphics.Point;\nimport android.graphics.Rect;\nimport android.hardware.Camera;\nimport android.os.Build;\nimport android.util.Log;\n\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.regex.Pattern;\n\n/**\n * Utility methods for configuring the Android camera.\n *\n * @author Sean Owen\n */\n@SuppressWarnings(\"deprecation\") // camera APIs\npublic final class CameraConfigurationUtils {\n\n    private static final String TAG = \"CameraConfiguration\";\n\n    private static final Pattern SEMICOLON = Pattern.compile(\";\");\n\n    private static final int MIN_PREVIEW_PIXELS = 480 * 320; // normal screen\n    private static final float MAX_EXPOSURE_COMPENSATION = 1.5f;\n    private static final float MIN_EXPOSURE_COMPENSATION = 0.0f;\n    private static final double MAX_ASPECT_DISTORTION = 0.15;\n    private static final int MIN_FPS = 10;\n    private static final int MAX_FPS = 20;\n    private static final int AREA_PER_1000 = 400;\n\n    private CameraConfigurationUtils() {\n    }\n\n    public static void setFocus(Camera.Parameters parameters,\n                                boolean autoFocus,\n                                boolean disableContinuous,\n                                boolean safeMode) {\n        List<String> supportedFocusModes = parameters.getSupportedFocusModes();\n        String focusMode = null;\n        if (autoFocus) {\n            if (safeMode || disableContinuous) {\n                focusMode = findSettableValue(\"focus mode\",\n                        supportedFocusModes,\n                        Camera.Parameters.FOCUS_MODE_AUTO);\n            } else {\n                focusMode = findSettableValue(\"focus mode\",\n                        supportedFocusModes,\n                        Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE,\n                        Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO,\n                        Camera.Parameters.FOCUS_MODE_AUTO);\n            }\n        }\n        // Maybe selected auto-focus but not available, so fall through here:\n        if (!safeMode && focusMode == null) {\n            focusMode = findSettableValue(\"focus mode\",\n                    supportedFocusModes,\n                    Camera.Parameters.FOCUS_MODE_MACRO,\n                    Camera.Parameters.FOCUS_MODE_EDOF);\n        }\n        if (focusMode != null) {\n            if (focusMode.equals(parameters.getFocusMode())) {\n                Log.i(TAG, \"Focus mode already set to \" + focusMode);\n            } else {\n                parameters.setFocusMode(focusMode);\n            }\n        }\n    }\n\n    public static void setTorch(Camera.Parameters parameters, boolean on) {\n        List<String> supportedFlashModes = parameters.getSupportedFlashModes();\n        String flashMode;\n        if (on) {\n            flashMode = findSettableValue(\"flash mode\",\n                    supportedFlashModes,\n                    Camera.Parameters.FLASH_MODE_TORCH,\n                    Camera.Parameters.FLASH_MODE_ON);\n        } else {\n            flashMode = findSettableValue(\"flash mode\",\n                    supportedFlashModes,\n                    Camera.Parameters.FLASH_MODE_OFF);\n        }\n        if (flashMode != null) {\n            if (flashMode.equals(parameters.getFlashMode())) {\n                Log.i(TAG, \"Flash mode already set to \" + flashMode);\n            } else {\n                Log.i(TAG, \"Setting flash mode to \" + flashMode);\n                parameters.setFlashMode(flashMode);\n            }\n        }\n    }\n\n    public static void setBestExposure(Camera.Parameters parameters, boolean lightOn) {\n        int minExposure = parameters.getMinExposureCompensation();\n        int maxExposure = parameters.getMaxExposureCompensation();\n        float step = parameters.getExposureCompensationStep();\n        if ((minExposure != 0 || maxExposure != 0) && step > 0.0f) {\n            // Set low when light is on\n            float targetCompensation = lightOn ? MIN_EXPOSURE_COMPENSATION : MAX_EXPOSURE_COMPENSATION;\n            int compensationSteps = Math.round(targetCompensation / step);\n            float actualCompensation = step * compensationSteps;\n            // Clamp value:\n            compensationSteps = Math.max(Math.min(compensationSteps, maxExposure), minExposure);\n            if (parameters.getExposureCompensation() == compensationSteps) {\n                Log.i(TAG, \"Exposure compensation already set to \" + compensationSteps + \" / \" + actualCompensation);\n            } else {\n                Log.i(TAG, \"Setting exposure compensation to \" + compensationSteps + \" / \" + actualCompensation);\n                parameters.setExposureCompensation(compensationSteps);\n            }\n        } else {\n            Log.i(TAG, \"Camera does not support exposure compensation\");\n        }\n    }\n\n    public static void setBestPreviewFPS(Camera.Parameters parameters) {\n        setBestPreviewFPS(parameters, MIN_FPS, MAX_FPS);\n    }\n\n    public static void setBestPreviewFPS(Camera.Parameters parameters, int minFPS, int maxFPS) {\n        List<int[]> supportedPreviewFpsRanges = parameters.getSupportedPreviewFpsRange();\n        Log.i(TAG, \"Supported FPS ranges: \" + toString(supportedPreviewFpsRanges));\n        if (supportedPreviewFpsRanges != null && !supportedPreviewFpsRanges.isEmpty()) {\n            int[] suitableFPSRange = null;\n            for (int[] fpsRange : supportedPreviewFpsRanges) {\n                int thisMin = fpsRange[Camera.Parameters.PREVIEW_FPS_MIN_INDEX];\n                int thisMax = fpsRange[Camera.Parameters.PREVIEW_FPS_MAX_INDEX];\n                if (thisMin >= minFPS * 1000 && thisMax <= maxFPS * 1000) {\n                    suitableFPSRange = fpsRange;\n                    break;\n                }\n            }\n            if (suitableFPSRange == null) {\n                Log.i(TAG, \"No suitable FPS range?\");\n            } else {\n                int[] currentFpsRange = new int[2];\n                parameters.getPreviewFpsRange(currentFpsRange);\n                if (Arrays.equals(currentFpsRange, suitableFPSRange)) {\n                    Log.i(TAG, \"FPS range already set to \" + Arrays.toString(suitableFPSRange));\n                } else {\n                    Log.i(TAG, \"Setting FPS range to \" + Arrays.toString(suitableFPSRange));\n                    parameters.setPreviewFpsRange(suitableFPSRange[Camera.Parameters.PREVIEW_FPS_MIN_INDEX],\n                            suitableFPSRange[Camera.Parameters.PREVIEW_FPS_MAX_INDEX]);\n                }\n            }\n        }\n    }\n\n    public static void setFocusArea(Camera.Parameters parameters) {\n        if (parameters.getMaxNumFocusAreas() > 0) {\n            Log.i(TAG, \"Old focus areas: \" + toString(parameters.getFocusAreas()));\n            List<Camera.Area> middleArea = buildMiddleArea(AREA_PER_1000);\n            Log.i(TAG, \"Setting focus area to : \" + toString(middleArea));\n            parameters.setFocusAreas(middleArea);\n        } else {\n            Log.i(TAG, \"Device does not support focus areas\");\n        }\n    }\n\n    public static void setMetering(Camera.Parameters parameters) {\n        if (parameters.getMaxNumMeteringAreas() > 0) {\n            Log.i(TAG, \"Old metering areas: \" + parameters.getMeteringAreas());\n            List<Camera.Area> middleArea = buildMiddleArea(AREA_PER_1000);\n            Log.i(TAG, \"Setting metering area to : \" + toString(middleArea));\n            parameters.setMeteringAreas(middleArea);\n        } else {\n            Log.i(TAG, \"Device does not support metering areas\");\n        }\n    }\n\n    private static List<Camera.Area> buildMiddleArea(int areaPer1000) {\n        return Collections.singletonList(\n                new Camera.Area(new Rect(-areaPer1000, -areaPer1000, areaPer1000, areaPer1000), 1));\n    }\n\n    public static void setVideoStabilization(Camera.Parameters parameters) {\n        if (parameters.isVideoStabilizationSupported()) {\n            if (parameters.getVideoStabilization()) {\n                Log.i(TAG, \"Video stabilization already enabled\");\n            } else {\n                Log.i(TAG, \"Enabling video stabilization...\");\n                parameters.setVideoStabilization(true);\n            }\n        } else {\n            Log.i(TAG, \"This device does not support video stabilization\");\n        }\n    }\n\n    public static void setBarcodeSceneMode(Camera.Parameters parameters) {\n        if (Camera.Parameters.SCENE_MODE_BARCODE.equals(parameters.getSceneMode())) {\n            Log.i(TAG, \"Barcode scene mode already set\");\n            return;\n        }\n        String sceneMode = findSettableValue(\"scene mode\",\n                parameters.getSupportedSceneModes(),\n                Camera.Parameters.SCENE_MODE_BARCODE);\n        if (sceneMode != null) {\n            parameters.setSceneMode(sceneMode);\n        }\n    }\n\n    public static void setZoom(Camera.Parameters parameters, double targetZoomRatio) {\n        if (parameters.isZoomSupported()) {\n            Integer zoom = indexOfClosestZoom(parameters, targetZoomRatio);\n            if (zoom == null) {\n                return;\n            }\n            if (parameters.getZoom() == zoom) {\n                Log.i(TAG, \"Zoom is already set to \" + zoom);\n            } else {\n                Log.i(TAG, \"Setting zoom to \" + zoom);\n                parameters.setZoom(zoom);\n            }\n        } else {\n            Log.i(TAG, \"Zoom is not supported\");\n        }\n    }\n\n    private static Integer indexOfClosestZoom(Camera.Parameters parameters, double targetZoomRatio) {\n        List<Integer> ratios = parameters.getZoomRatios();\n        Log.i(TAG, \"Zoom ratios: \" + ratios);\n        int maxZoom = parameters.getMaxZoom();\n        if (ratios == null || ratios.isEmpty() || ratios.size() != maxZoom + 1) {\n            Log.w(TAG, \"Invalid zoom ratios!\");\n            return null;\n        }\n        double target100 = 100.0 * targetZoomRatio;\n        double smallestDiff = Double.POSITIVE_INFINITY;\n        int closestIndex = 0;\n        for (int i = 0; i < ratios.size(); i++) {\n            double diff = Math.abs(ratios.get(i) - target100);\n            if (diff < smallestDiff) {\n                smallestDiff = diff;\n                closestIndex = i;\n            }\n        }\n        Log.i(TAG, \"Chose zoom ratio of \" + (ratios.get(closestIndex) / 100.0));\n        return closestIndex;\n    }\n\n    public static void setInvertColor(Camera.Parameters parameters) {\n        if (Camera.Parameters.EFFECT_NEGATIVE.equals(parameters.getColorEffect())) {\n            Log.i(TAG, \"Negative effect already set\");\n            return;\n        }\n        String colorMode = findSettableValue(\"color effect\",\n                parameters.getSupportedColorEffects(),\n                Camera.Parameters.EFFECT_NEGATIVE);\n        if (colorMode != null) {\n            parameters.setColorEffect(colorMode);\n        }\n    }\n\n    public static Point findBestPreviewSizeValue(Camera.Parameters parameters, Point screenResolution) {\n\n        List<Camera.Size> rawSupportedSizes = parameters.getSupportedPreviewSizes();\n        if (rawSupportedSizes == null) {\n            Log.w(TAG, \"Device returned no supported preview sizes; using default\");\n            Camera.Size defaultSize = parameters.getPreviewSize();\n            if (defaultSize == null) {\n                throw new IllegalStateException(\"Parameters contained no preview size!\");\n            }\n            return new Point(defaultSize.width, defaultSize.height);\n        }\n\n        if (Log.isLoggable(TAG, Log.INFO)) {\n            StringBuilder previewSizesString = new StringBuilder();\n            for (Camera.Size size : rawSupportedSizes) {\n                previewSizesString.append(size.width).append('x').append(size.height).append(' ');\n            }\n            Log.i(TAG, \"Supported preview sizes: \" + previewSizesString);\n        }\n\n        double screenAspectRatio = screenResolution.x / (double) screenResolution.y;\n\n        // Find a suitable size, with max resolution\n        int maxResolution = 0;\n        Camera.Size maxResPreviewSize = null;\n        for (Camera.Size size : rawSupportedSizes) {\n            int realWidth = size.width;\n            int realHeight = size.height;\n            int resolution = realWidth * realHeight;\n            if (resolution < MIN_PREVIEW_PIXELS) {\n                continue;\n            }\n\n            boolean isCandidatePortrait = realWidth < realHeight;\n            int maybeFlippedWidth = isCandidatePortrait ? realHeight : realWidth;\n            int maybeFlippedHeight = isCandidatePortrait ? realWidth : realHeight;\n            double aspectRatio = maybeFlippedWidth / (double) maybeFlippedHeight;\n            double distortion = Math.abs(aspectRatio - screenAspectRatio);\n            if (distortion > MAX_ASPECT_DISTORTION) {\n                continue;\n            }\n\n            if (maybeFlippedWidth == screenResolution.x && maybeFlippedHeight == screenResolution.y) {\n                Point exactPoint = new Point(realWidth, realHeight);\n                Log.i(TAG, \"Found preview size exactly matching screen size: \" + exactPoint);\n                return exactPoint;\n            }\n\n            // Resolution is suitable; record the one with max resolution\n            if (resolution > maxResolution) {\n                maxResolution = resolution;\n                maxResPreviewSize = size;\n            }\n        }\n\n        // If no exact match, use largest preview size. This was not a great idea on older devices because\n        // of the additional computation needed. We're likely to get here on newer Android 4+ devices, where\n        // the CPU is much more powerful.\n        if (maxResPreviewSize != null) {\n            Point largestSize = new Point(maxResPreviewSize.width, maxResPreviewSize.height);\n            Log.i(TAG, \"Using largest suitable preview size: \" + largestSize);\n            return largestSize;\n        }\n\n        // If there is nothing at all suitable, return current preview size\n        Camera.Size defaultPreview = parameters.getPreviewSize();\n        if (defaultPreview == null) {\n            throw new IllegalStateException(\"Parameters contained no preview size!\");\n        }\n        Point defaultSize = new Point(defaultPreview.width, defaultPreview.height);\n        Log.i(TAG, \"No suitable preview sizes, using default: \" + defaultSize);\n        return defaultSize;\n    }\n\n    private static String findSettableValue(String name,\n                                            Collection<String> supportedValues,\n                                            String... desiredValues) {\n        Log.i(TAG, \"Requesting \" + name + \" value from among: \" + Arrays.toString(desiredValues));\n        Log.i(TAG, \"Supported \" + name + \" values: \" + supportedValues);\n        if (supportedValues != null) {\n            for (String desiredValue : desiredValues) {\n                if (supportedValues.contains(desiredValue)) {\n                    Log.i(TAG, \"Can set \" + name + \" to: \" + desiredValue);\n                    return desiredValue;\n                }\n            }\n        }\n        Log.i(TAG, \"No supported values match\");\n        return null;\n    }\n\n    private static String toString(Collection<int[]> arrays) {\n        if (arrays == null || arrays.isEmpty()) {\n            return \"[]\";\n        }\n        StringBuilder buffer = new StringBuilder();\n        buffer.append('[');\n        Iterator<int[]> it = arrays.iterator();\n        while (it.hasNext()) {\n            buffer.append(Arrays.toString(it.next()));\n            if (it.hasNext()) {\n                buffer.append(\", \");\n            }\n        }\n        buffer.append(']');\n        return buffer.toString();\n    }\n\n    private static String toString(Iterable<Camera.Area> areas) {\n        if (areas == null) {\n            return null;\n        }\n        StringBuilder result = new StringBuilder();\n        for (Camera.Area area : areas) {\n            result.append(area.rect).append(':').append(area.weight).append(' ');\n        }\n        return result.toString();\n    }\n\n    public static String collectStats(Camera.Parameters parameters) {\n        return collectStats(parameters.flatten());\n    }\n\n    public static String collectStats(CharSequence flattenedParams) {\n        StringBuilder result = new StringBuilder(1000);\n\n        result.append(\"BOARD=\").append(Build.BOARD).append('\\n');\n        result.append(\"BRAND=\").append(Build.BRAND).append('\\n');\n        result.append(\"CPU_ABI=\").append(Build.CPU_ABI).append('\\n');\n        result.append(\"DEVICE=\").append(Build.DEVICE).append('\\n');\n        result.append(\"DISPLAY=\").append(Build.DISPLAY).append('\\n');\n        result.append(\"FINGERPRINT=\").append(Build.FINGERPRINT).append('\\n');\n        result.append(\"HOST=\").append(Build.HOST).append('\\n');\n        result.append(\"ID=\").append(Build.ID).append('\\n');\n        result.append(\"MANUFACTURER=\").append(Build.MANUFACTURER).append('\\n');\n        result.append(\"MODEL=\").append(Build.MODEL).append('\\n');\n        result.append(\"PRODUCT=\").append(Build.PRODUCT).append('\\n');\n        result.append(\"TAGS=\").append(Build.TAGS).append('\\n');\n        result.append(\"TIME=\").append(Build.TIME).append('\\n');\n        result.append(\"TYPE=\").append(Build.TYPE).append('\\n');\n        result.append(\"USER=\").append(Build.USER).append('\\n');\n        result.append(\"VERSION.CODENAME=\").append(Build.VERSION.CODENAME).append('\\n');\n        result.append(\"VERSION.INCREMENTAL=\").append(Build.VERSION.INCREMENTAL).append('\\n');\n        result.append(\"VERSION.RELEASE=\").append(Build.VERSION.RELEASE).append('\\n');\n        result.append(\"VERSION.SDK_INT=\").append(Build.VERSION.SDK_INT).append('\\n');\n\n        if (flattenedParams != null) {\n            String[] params = SEMICOLON.split(flattenedParams);\n            Arrays.sort(params);\n            for (String param : params) {\n                result.append(param).append('\\n');\n            }\n        }\n\n        return result.toString();\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- qrcode/src/main/java/com/google/zxing/client/android/camera/CameraConfigurationUtils.java	(date 1545458417000)
+++ qrcode/src/main/java/com/google/zxing/client/android/camera/CameraConfigurationUtils.java	(revision )
@@ -37,14 +37,15 @@
 @SuppressWarnings("deprecation") // camera APIs
 public final class CameraConfigurationUtils {
 
-    private static final String TAG = "CameraConfiguration";
+    private static final String TAG = "CameraConfigurationU";
 
     private static final Pattern SEMICOLON = Pattern.compile(";");
 
     private static final int MIN_PREVIEW_PIXELS = 480 * 320; // normal screen
     private static final float MAX_EXPOSURE_COMPENSATION = 1.5f;
     private static final float MIN_EXPOSURE_COMPENSATION = 0.0f;
-    private static final double MAX_ASPECT_DISTORTION = 0.15;
+    //    private static final double MAX_ASPECT_DISTORTION = 0.15;
+    private static final double MAX_ASPECT_DISTORTION = 0.20;//原值0.15，为了平板
     private static final int MIN_FPS = 10;
     private static final int MAX_FPS = 20;
     private static final int AREA_PER_1000 = 400;
@@ -271,7 +272,7 @@
     }
 
     public static Point findBestPreviewSizeValue(Camera.Parameters parameters, Point screenResolution) {
-
+        //获取全部支持预览的分辨率
         List<Camera.Size> rawSupportedSizes = parameters.getSupportedPreviewSizes();
         if (rawSupportedSizes == null) {
             Log.w(TAG, "Device returned no supported preview sizes; using default");
@@ -290,8 +291,14 @@
             Log.i(TAG, "Supported preview sizes: " + previewSizesString);
         }
 
+        //分辨率比例(大值比小值)
         double screenAspectRatio = screenResolution.x / (double) screenResolution.y;
 
+        //竖屏
+        if (screenResolution.x < screenResolution.y) {
+            screenAspectRatio = screenResolution.y / (double) screenResolution.x;
+        }
+
         // Find a suitable size, with max resolution
         int maxResolution = 0;
         Camera.Size maxResPreviewSize = null;
Index: qrcode/src/main/res/xml/preferences.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?><!--\n Copyright (C) 2008 ZXing authors\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n -->\n<PreferenceScreen xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <PreferenceCategory android:title=\"@string/preferences_scanning_title\">\n        <CheckBoxPreference\n            android:defaultValue=\"true\"\n            android:key=\"preferences_decode_1D_product\"\n            android:title=\"@string/preferences_decode_1D_product_title\" />\n        <CheckBoxPreference\n            android:defaultValue=\"true\"\n            android:key=\"preferences_decode_1D_industrial\"\n            android:title=\"@string/preferences_decode_1D_industrial_title\" />\n        <CheckBoxPreference\n            android:defaultValue=\"true\"\n            android:key=\"preferences_decode_QR\"\n            android:title=\"@string/preferences_decode_QR_title\" />\n        <CheckBoxPreference\n            android:defaultValue=\"true\"\n            android:key=\"preferences_decode_Data_Matrix\"\n            android:title=\"@string/preferences_decode_Data_Matrix_title\" />\n        <CheckBoxPreference\n            android:defaultValue=\"false\"\n            android:key=\"preferences_decode_Aztec\"\n            android:title=\"@string/preferences_decode_Aztec_title\" />\n        <CheckBoxPreference\n            android:defaultValue=\"false\"\n            android:key=\"preferences_decode_PDF417\"\n            android:title=\"@string/preferences_decode_PDF417_title\" />\n    </PreferenceCategory>\n    <PreferenceCategory android:title=\"@string/preferences_actions_title\">\n        <CheckBoxPreference\n            android:defaultValue=\"true\"\n            android:key=\"preferences_play_beep\"\n            android:title=\"@string/preferences_play_beep_title\" />\n        <CheckBoxPreference\n            android:defaultValue=\"false\"\n            android:key=\"preferences_vibrate\"\n            android:title=\"@string/preferences_vibrate_title\" />\n        <CheckBoxPreference\n            android:defaultValue=\"true\"\n            android:key=\"preferences_copy_to_clipboard\"\n            android:title=\"@string/preferences_copy_to_clipboard_title\" />\n        <CheckBoxPreference\n            android:defaultValue=\"false\"\n            android:key=\"preferences_auto_open_web\"\n            android:title=\"@string/preferences_auto_open_web_title\" />\n        <CheckBoxPreference\n            android:defaultValue=\"false\"\n            android:key=\"preferences_remember_duplicates\"\n            android:summary=\"@string/preferences_remember_duplicates_summary\"\n            android:title=\"@string/preferences_remember_duplicates_title\" />\n        <CheckBoxPreference\n            android:defaultValue=\"true\"\n            android:key=\"preferences_history\"\n            android:summary=\"@string/preferences_history_summary\"\n            android:title=\"@string/preferences_history_title\" />\n        <CheckBoxPreference\n            android:defaultValue=\"true\"\n            android:key=\"preferences_supplemental\"\n            android:summary=\"@string/preferences_supplemental_summary\"\n            android:title=\"@string/preferences_supplemental_title\" />\n    </PreferenceCategory>\n    <PreferenceCategory android:title=\"@string/preferences_general_title\">\n        <ListPreference\n            android:defaultValue=\"OFF\"\n            android:entries=\"@array/preferences_front_light_options\"\n            android:entryValues=\"@array/preferences_front_light_values\"\n            android:key=\"preferences_front_light_mode\"\n            android:summary=\"@string/preferences_front_light_summary\"\n            android:title=\"@string/preferences_front_light_title\" />\n        <CheckBoxPreference\n            android:defaultValue=\"true\"\n            android:key=\"preferences_auto_focus\"\n            android:title=\"@string/preferences_auto_focus_title\" />\n        <CheckBoxPreference\n            android:defaultValue=\"false\"\n            android:key=\"preferences_invert_scan\"\n            android:summary=\"@string/preferences_invert_scan_summary\"\n            android:title=\"@string/preferences_invert_scan_title\" />\n        <CheckBoxPreference\n            android:defaultValue=\"false\"\n            android:key=\"preferences_bulk_mode\"\n            android:summary=\"@string/preferences_bulk_mode_summary\"\n            android:title=\"@string/preferences_bulk_mode_title\" />\n        <CheckBoxPreference\n            android:defaultValue=\"true\"\n            android:key=\"preferences_orientation\"\n            android:title=\"@string/preferences_orientation_title\" />\n    </PreferenceCategory>\n    <PreferenceCategory android:title=\"@string/preferences_result_title\">\n        <EditTextPreference\n            android:key=\"preferences_custom_product_search\"\n            android:summary=\"@string/preferences_custom_product_search_summary\"\n            android:title=\"@string/preferences_custom_product_search_title\" />\n        <ListPreference\n            android:defaultValue=\"-\"\n            android:entries=\"@array/country_codes\"\n            android:entryValues=\"@array/country_codes\"\n            android:key=\"preferences_search_country\"\n            android:title=\"@string/preferences_search_country\" />\n    </PreferenceCategory>\n    <PreferenceCategory android:title=\"@string/preferences_device_bug_workarounds_title\">\n        <CheckBoxPreference\n            android:defaultValue=\"true\"\n            android:key=\"preferences_disable_continuous_focus\"\n            android:summary=\"@string/preferences_disable_continuous_focus_summary\"\n            android:title=\"@string/preferences_disable_continuous_focus_title\" />\n        <CheckBoxPreference\n            android:defaultValue=\"true\"\n            android:key=\"preferences_disable_exposure\"\n            android:title=\"@string/preferences_disable_exposure_title\" />\n        <CheckBoxPreference\n            android:defaultValue=\"true\"\n            android:key=\"preferences_disable_metering\"\n            android:title=\"@string/preferences_disable_metering_title\" />\n        <CheckBoxPreference\n            android:defaultValue=\"true\"\n            android:key=\"preferences_disable_barcode_scene_mode\"\n            android:title=\"@string/preferences_disable_barcode_scene_mode_title\" />\n    </PreferenceCategory>\n</PreferenceScreen>\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- qrcode/src/main/res/xml/preferences.xml	(date 1545458417000)
+++ qrcode/src/main/res/xml/preferences.xml	(revision )
@@ -95,10 +95,6 @@
             android:key="preferences_bulk_mode"
             android:summary="@string/preferences_bulk_mode_summary"
             android:title="@string/preferences_bulk_mode_title" />
-        <CheckBoxPreference
-            android:defaultValue="true"
-            android:key="preferences_orientation"
-            android:title="@string/preferences_orientation_title" />
     </PreferenceCategory>
     <PreferenceCategory android:title="@string/preferences_result_title">
         <EditTextPreference
